<!doctype html><html lang=en><head><title>使用广度优先与启发式搜索算法求解的重排九宫问题 // yuaay</title>
<link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.139.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="yuaay"><meta name=description content><link rel=stylesheet href=/css/main.min.6ebe00cfa7759a5c422430d5c2a659c696627ccf19379685a28a3aec1859af90.css><meta name=twitter:card content="summary"><meta name=twitter:title content="使用广度优先与启发式搜索算法求解的重排九宫问题"><meta name=twitter:description content="前言 重排九宫就是重新排列九宫图的意思。这是根据当时盛行研究的数学游戏——纵横图（也叫幻方或魔方阵）发展来的，九宫游戏的起源，更可追溯到我国远古神话历史时代的河图、洛书。重排九宫则属滑块类游戏。在使用算术的同时，还必须推动方块使其到相对应的位置。其玩法是在3×3方格盘上，放有1-8八个数，剩下一格为空，每一空格其周围的数字可移至空格。先设定初始排列数字，然后开始思考如何以最少的移动次数来达到目的排列状态。
目前，针对该问题的一般解法为广度优先搜索。对于某一个确定的初始状态和目标状态，通过广度优先的方式，遍历所有的可能性，最终找到一条从初始状态到目标状态的路径，或者无解。
此外，由于广度优先是盲目搜索的，也可以结合启发式算法，如A*算法，在广度优先搜索的基础上，加入一个启发式函数来优化搜索过程，最终常常可以减少找到解时所生成的节点数量，增强算法的性能。
摘要 本文结合广度优先搜索的思想，编写C++代码成功实现了重排九宫问题的计算机求解。对于任意的初始状态及目的状态，如果有解，代码会输出从初始状态到目标状态最短路径。
此外，在尝试使用多个示例时，本文也发现使用广度优先搜索的重排九宫算法对某些目标状态的求解产生了大量不必要的节点。在查阅相关资料后，本文在广度优先搜索的基础上，结合了A*算法等启发式思想，成功改进了相关算法，能够在大部分情况下，更好的求解重排九宫问题。
算法描述 广度优先搜索 算法 将九宫格的每一种可能的摆放方式定义为九宫格的一种状态。初始时，程序读入用户输入的初始状态与目标状态，分别存储在head和target结构中。之后，对于每一次程序执行，定义队列wait表示等待处理的状态，定义集合used表示已经处理过的状态，防止重复处理。在算法正式执行前，将head节点置入wait队列，used清零。
之后，从wait队列中取出状态，如果该状态为目标状态，算法结束，找到路径；如果该状态不是目标状态，将经由该状态可以抵达、且不再used集合中的状态加入wait队列及used集合。然后，重复从wait队列取出状态进行判断，直到找到目标状态或者wait队列为空时，算法结束。
程序结构 项目文件结构如下：
📦root
┣ 📂include
┃ ┣ 📜BFS.h
┃ ┗ 📜Node.h
┣ 📂src
┃ ┣ 📜BFS.cpp
┃ ┣ 📜Node.cpp
┃ ┗ 📜main.cpp
┣ 📜CMakeLists.txt
┣ 📜LICENSE
┗ 📜README.md
其中，在Node.h文件中定义了表示九宫格状态的结构体struct Node,代码如下：
struct Node { int content[ROW][COL]; // 数据成员 int r; int c; Node* parent; // 构造函数声明 Node(); // 成员函数声明 void print(); void set_value(int row, int col, int value, Node* p=nullptr); Node* up(); Node* left(); Node* right(); Node* down(); bool operator==(const Node& other) const; bool operator!=(const Node& other) const; bool operator<(const Node& other) const; }; content表示该状态内容，r、c表示空格所在位置，parent是指向生成该状态的父状态。对于==、！=、<则定义了忽略父节点指针的重载运算。"><meta property="og:url" content="https://xiongyuaay.github.io/posts/ai/%E9%87%8D%E6%8E%92%E4%B9%9D%E5%AE%AB/"><meta property="og:site_name" content="yuaay"><meta property="og:title" content="使用广度优先与启发式搜索算法求解的重排九宫问题"><meta property="og:description" content="前言 重排九宫就是重新排列九宫图的意思。这是根据当时盛行研究的数学游戏——纵横图（也叫幻方或魔方阵）发展来的，九宫游戏的起源，更可追溯到我国远古神话历史时代的河图、洛书。重排九宫则属滑块类游戏。在使用算术的同时，还必须推动方块使其到相对应的位置。其玩法是在3×3方格盘上，放有1-8八个数，剩下一格为空，每一空格其周围的数字可移至空格。先设定初始排列数字，然后开始思考如何以最少的移动次数来达到目的排列状态。
目前，针对该问题的一般解法为广度优先搜索。对于某一个确定的初始状态和目标状态，通过广度优先的方式，遍历所有的可能性，最终找到一条从初始状态到目标状态的路径，或者无解。
此外，由于广度优先是盲目搜索的，也可以结合启发式算法，如A*算法，在广度优先搜索的基础上，加入一个启发式函数来优化搜索过程，最终常常可以减少找到解时所生成的节点数量，增强算法的性能。
摘要 本文结合广度优先搜索的思想，编写C++代码成功实现了重排九宫问题的计算机求解。对于任意的初始状态及目的状态，如果有解，代码会输出从初始状态到目标状态最短路径。
此外，在尝试使用多个示例时，本文也发现使用广度优先搜索的重排九宫算法对某些目标状态的求解产生了大量不必要的节点。在查阅相关资料后，本文在广度优先搜索的基础上，结合了A*算法等启发式思想，成功改进了相关算法，能够在大部分情况下，更好的求解重排九宫问题。
算法描述 广度优先搜索 算法 将九宫格的每一种可能的摆放方式定义为九宫格的一种状态。初始时，程序读入用户输入的初始状态与目标状态，分别存储在head和target结构中。之后，对于每一次程序执行，定义队列wait表示等待处理的状态，定义集合used表示已经处理过的状态，防止重复处理。在算法正式执行前，将head节点置入wait队列，used清零。
之后，从wait队列中取出状态，如果该状态为目标状态，算法结束，找到路径；如果该状态不是目标状态，将经由该状态可以抵达、且不再used集合中的状态加入wait队列及used集合。然后，重复从wait队列取出状态进行判断，直到找到目标状态或者wait队列为空时，算法结束。
程序结构 项目文件结构如下：
📦root
┣ 📂include
┃ ┣ 📜BFS.h
┃ ┗ 📜Node.h
┣ 📂src
┃ ┣ 📜BFS.cpp
┃ ┣ 📜Node.cpp
┃ ┗ 📜main.cpp
┣ 📜CMakeLists.txt
┣ 📜LICENSE
┗ 📜README.md
其中，在Node.h文件中定义了表示九宫格状态的结构体struct Node,代码如下：
struct Node { int content[ROW][COL]; // 数据成员 int r; int c; Node* parent; // 构造函数声明 Node(); // 成员函数声明 void print(); void set_value(int row, int col, int value, Node* p=nullptr); Node* up(); Node* left(); Node* right(); Node* down(); bool operator==(const Node& other) const; bool operator!=(const Node& other) const; bool operator<(const Node& other) const; }; content表示该状态内容，r、c表示空格所在位置，parent是指向生成该状态的父状态。对于==、！=、<则定义了忽略父节点指针的重载运算。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-04T17:29:50+08:00"><meta property="article:modified_time" content="2024-12-04T17:29:50+08:00"><meta property="article:tag" content="Ai"><meta property="article:tag" content="Course"></head><body><header class=app-header><a href=https://xiongyuaay.github.io/><img class=app-header-avatar src=/avatar.jpg alt=yuaay></a>
<span class=app-header-title>yuaay</span><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a></nav><p>电子世界的幽灵</p><div class=app-header-social><a href=https://github.com/xiongyuaay target=_blank rel="noreferrer noopener me"><svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentcolor"><title>GitHub</title><path d="M12 .297c-6.63.0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.606-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
</a><a href=xiongyuaay@gmail.com target=_blank rel="noreferrer noopener me"><svg class="icon icon-mail" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>mail</title><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>使用广度优先与启发式搜索算法求解的重排九宫问题</h1><div class=post-meta><div><svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
Dec 4, 2024</div><div><svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
9 min read</div><div><svg class="icon icon-tag" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
<a class=tag href=https://xiongyuaay.github.io/tags/ai/>Ai</a>
<a class=tag href=https://xiongyuaay.github.io/tags/course/>Course</a></div></div></header><div class=post-content><h1 id=前言>前言</h1><p>重排九宫就是重新排列九宫图的意思。这是根据当时盛行研究的数学游戏——纵横图（也叫幻方或魔方阵）发展来的，九宫游戏的起源，更可追溯到我国远古神话历史时代的河图、洛书。重排九宫则属滑块类游戏。在使用算术的同时，还必须推动方块使其到相对应的位置。其玩法是在3×3方格盘上，放有1-8八个数，剩下一格为空，每一空格其周围的数字可移至空格。先设定初始排列数字，然后开始思考如何以最少的移动次数来达到目的排列状态。</p><p>目前，针对该问题的一般解法为广度优先搜索。对于某一个确定的初始状态和目标状态，通过广度优先的方式，遍历所有的可能性，最终找到一条从初始状态到目标状态的路径，或者无解。</p><p>此外，由于广度优先是盲目搜索的，也可以结合启发式算法，如A*算法，在广度优先搜索的基础上，加入一个启发式函数来优化搜索过程，最终常常可以减少找到解时所生成的节点数量，增强算法的性能。</p><h1 id=摘要>摘要</h1><p>本文结合广度优先搜索的思想，编写C++代码成功实现了重排九宫问题的计算机求解。对于任意的初始状态及目的状态，如果有解，代码会输出从初始状态到目标状态最短路径。</p><p>此外，在尝试使用多个示例时，本文也发现使用广度优先搜索的重排九宫算法对某些目标状态的求解产生了大量不必要的节点。在查阅相关资料后，本文在广度优先搜索的基础上，结合了A*算法等启发式思想，成功改进了相关算法，能够在大部分情况下，更好的求解重排九宫问题。</p><h1 id=算法描述>算法描述</h1><h2 id=广度优先搜索>广度优先搜索</h2><h3 id=算法>算法</h3><p>将九宫格的每一种可能的摆放方式定义为九宫格的一种状态。初始时，程序读入用户输入的初始状态与目标状态，分别存储在head和target结构中。之后，对于每一次程序执行，定义队列wait表示等待处理的状态，定义集合used表示已经处理过的状态，防止重复处理。在算法正式执行前，将head节点置入wait队列，used清零。</p><p>之后，从wait队列中取出状态，如果该状态为目标状态，算法结束，找到路径；如果该状态不是目标状态，将经由该状态可以抵达、且不再used集合中的状态加入wait队列及used集合。然后，重复从wait队列取出状态进行判断，直到找到目标状态或者wait队列为空时，算法结束。</p><h3 id=程序结构>程序结构</h3><p>项目文件结构如下：</p><p>📦root</p><p>┣ 📂include</p><p>┃ ┣ 📜BFS.h</p><p>┃ ┗ 📜Node.h</p><p>┣ 📂src</p><p>┃ ┣ 📜BFS.cpp</p><p>┃ ┣ 📜Node.cpp</p><p>┃ ┗ 📜main.cpp</p><p>┣ 📜CMakeLists.txt</p><p>┣ 📜LICENSE</p><p>┗ 📜README.md</p><p>其中，在Node.h文件中定义了表示九宫格状态的结构体struct Node,代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> content[ROW][COL]; <span style=color:#75715e>// 数据成员
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> r;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c;
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> parent;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 构造函数声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Node();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 成员函数声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_value</span>(<span style=color:#66d9ef>int</span> row, <span style=color:#66d9ef>int</span> col, <span style=color:#66d9ef>int</span> value, Node<span style=color:#f92672>*</span> p<span style=color:#f92672>=</span><span style=color:#66d9ef>nullptr</span>);
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> <span style=color:#a6e22e>up</span>();
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> <span style=color:#a6e22e>left</span>();
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> <span style=color:#a6e22e>right</span>();
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> <span style=color:#a6e22e>down</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>==</span>(<span style=color:#66d9ef>const</span> Node<span style=color:#f92672>&amp;</span> other) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>!=</span>(<span style=color:#66d9ef>const</span> Node<span style=color:#f92672>&amp;</span> other) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>const</span> Node<span style=color:#f92672>&amp;</span> other) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>content表示该状态内容，r、c表示空格所在位置，parent是指向生成该状态的父状态。对于==、！=、&lt;则定义了忽略父节点指针的重载运算。</p><p>在BFS.h文件中，定义了BFS类，包含了使用广度优先搜索求解问题所需要的所有变量和函数，代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BFS</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Node head;
</span></span><span style=display:flex><span>    Node target;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> path;
</span></span><span style=display:flex><span>    set<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> used;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    BFS(<span style=color:#75715e>/* args */</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FindPath</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Print</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>NotUsed</span>(Node<span style=color:#f92672>&amp;</span> node);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>其中，head为初始状态，target为目标状态，path为最终的路径，used表示已经处理过的状态集合。函数FindPath用来寻找该具体问题的解，代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> BFS<span style=color:#f92672>::</span>FindPath()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    queue<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>*&gt;</span> wait;
</span></span><span style=display:flex><span>    wait.emplace(<span style=color:#f92672>&amp;</span>head);
</span></span><span style=display:flex><span>    used.insert(head);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>wait.empty())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> wait.front();
</span></span><span style=display:flex><span>        wait.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>curr <span style=color:#f92672>==</span> target)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            path.emplace_back(<span style=color:#f92672>*</span>curr);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (path.back().<span style=color:#66d9ef>operator</span><span style=color:#f92672>!=</span>(head))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                path.emplace_back(<span style=color:#f92672>*</span>(path.back().parent));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>up();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            wait.emplace(temp);
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>left();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>            wait.emplace(temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>right();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>            wait.emplace(temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>down();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>            wait.emplace(temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=流程图>流程图</h3><p>算法流程图如下：</p><p><img src=../../../static/images/%E9%87%8D%E6%8E%92%E4%B9%9D%E5%AE%AB/image.png alt="alt text"></p><h3 id=多次运行结果>多次运行结果</h3><p><strong>示例1</strong>
初始状态：
2 8 3
1 -1 4
7 6 5
目标状态：
1 2 3
8 -1 4
7 6 5
运行结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ae81ff>2</span> <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>3</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>   <span style=color:#ae81ff>4</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>5</span> 
</span></span><span style=display:flex><span> ↓
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>   <span style=color:#ae81ff>3</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>4</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>5</span> 
</span></span><span style=display:flex><span> ↓
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>4</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>5</span> 
</span></span><span style=display:flex><span> ↓
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> 
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>4</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>5</span> 
</span></span><span style=display:flex><span> ↓
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>8</span>   <span style=color:#ae81ff>4</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>5</span> 
</span></span></code></pre></div><p><strong>示例2</strong>
初始状态：
2 8 3
1 -1 4
7 6 5
目标状态：
2 4 3
1 8 -1
7 6 5
运行结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>请输入初始节点状态
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span> <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> -1 <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>8</span> -1
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> <span style=color:#ae81ff>6</span> 5请输入目标节点状态
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>没有从初始节点到目标节点的路径
</span></span></code></pre></div><p><strong>示例3</strong>
初始状态：
1 2 3
4 5 6
7 8 -1
目标状态：
1 2 3
-1 4 6
7 5 8
运行结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>6</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> <span style=color:#ae81ff>8</span>   
</span></span><span style=display:flex><span> ↓
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>6</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span>   <span style=color:#ae81ff>8</span> 
</span></span><span style=display:flex><span> ↓
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>   <span style=color:#ae81ff>6</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>8</span> 
</span></span><span style=display:flex><span> ↓
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> 
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>6</span> 
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>8</span> 
</span></span></code></pre></div><h2 id=启发式搜索>启发式搜索</h2><h3 id=算法-1>算法</h3><p>考虑到广度优先搜索中，节点的添加与处理是盲目的，常常会处理很多不必要的节点。为改善该问题，等待队列中的每一个待处理状态增添一个有启发式函数得到的预估从初始节点经由该节点到目标节点的代价。计算方法如下：</p><p>f(n)=g(n)+h(n)</p><ul><li>g(n) 是从初始状态到当前状态的实际代价（即已移动步数）。</li><li>h(n) 是当前状态到目标状态的估计代价。</li></ul><p>这里采用曼哈顿距离作为启发式函数，即对于每个数字 𝑑，计算它当前位置（x1, y1）和目标位置（x2, y2）的曼哈顿距离（|x1 - x2|+|y1 - y2|），再将这些曼哈顿距离求和得到估计代价。</p><p>之后，在从wait等待队列中取节点时，选择代价最小的节点而不是头部节点。</p><h3 id=程序结构-1>程序结构</h3><p>定义关键数据结构，不仅包含每个状态的Node节点，还包含该状态的生成层级与估计的从初始状态经由该状态到目标状态的代价。代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pNode</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> node;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> depth;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cost;
</span></span><span style=display:flex><span>    pNode()<span style=color:#f92672>:</span> node(<span style=color:#66d9ef>nullptr</span>), depth(<span style=color:#ae81ff>0</span>), cost(<span style=color:#ae81ff>0</span>) {}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>此外，为便于计算曼哈顿距离，为Astar类增添数据positions，记录target每个数字所在的位置。修改后Astar类代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Astar</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> BFS
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> positions;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Astar(<span style=color:#75715e>/* args */</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FindPath</span>() <span style=color:#66d9ef>override</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>ManhattanDistance</span>(Node<span style=color:#f92672>&amp;</span> node);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>其中，ManhattanDistance函数用于计算当前状态的曼哈顿距离。重写后的FindPath函数代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> Astar<span style=color:#f92672>::</span>FindPath()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    priority_queue<span style=color:#f92672>&lt;</span>pNode, vector<span style=color:#f92672>&lt;</span>pNode<span style=color:#f92672>&gt;</span>, ComparePNode<span style=color:#f92672>&gt;</span> wait;
</span></span><span style=display:flex><span>    pNode h;
</span></span><span style=display:flex><span>    h.node <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>head;
</span></span><span style=display:flex><span>    h.depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    h.cost <span style=color:#f92672>=</span> ManhattanDistance(head) <span style=color:#f92672>+</span> h.depth;
</span></span><span style=display:flex><span>    wait.emplace(h);
</span></span><span style=display:flex><span>    used.insert(head);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>wait.empty())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        pNode c <span style=color:#f92672>=</span> wait.top();
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> c.node;
</span></span><span style=display:flex><span>        wait.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>curr <span style=color:#f92672>==</span> target)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            path.emplace_back(<span style=color:#f92672>*</span>curr);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (path.back().<span style=color:#66d9ef>operator</span><span style=color:#f92672>!=</span>(head))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                path.emplace_back(<span style=color:#f92672>*</span>(path.back().parent));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>up();
</span></span><span style=display:flex><span>        pNode newpNode;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            newpNode.depth <span style=color:#f92672>=</span> c.depth<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            newpNode.cost <span style=color:#f92672>=</span> ManhattanDistance(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>+</span> newpNode.depth;
</span></span><span style=display:flex><span>            newpNode.node <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>            wait.emplace(newpNode);
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>left();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            newpNode.depth <span style=color:#f92672>=</span> c.depth<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            newpNode.cost <span style=color:#f92672>=</span> ManhattanDistance(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>+</span> newpNode.depth;
</span></span><span style=display:flex><span>            newpNode.node <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>            wait.emplace(newpNode);
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>right();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            newpNode.depth <span style=color:#f92672>=</span> c.depth<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            newpNode.cost <span style=color:#f92672>=</span> ManhattanDistance(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>+</span> newpNode.depth;
</span></span><span style=display:flex><span>            newpNode.node <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>            wait.emplace(newpNode);
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>down();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            newpNode.depth <span style=color:#f92672>=</span> c.depth<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            newpNode.cost <span style=color:#f92672>=</span> ManhattanDistance(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>+</span> newpNode.depth;
</span></span><span style=display:flex><span>            newpNode.node <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>            wait.emplace(newpNode);
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>将wait队列修改为使用自定义规则的优先队列存储，每次输出优先级最高（即预估代价最小）的节点进行处理。</p><h3 id=流程图-1>流程图</h3><p>使用启发式搜索的重排九宫算法修改了原先队列的数据结构，修改后程序的流程图如下：</p><p><img src=../../../static/images/%E9%87%8D%E6%8E%92%E4%B9%9D%E5%AE%AB/image-1.png alt="alt text"></p><h1 id=比较>比较</h1><p>选用多个示例，比较广度优先搜索与启发式搜索算法的结果，将两种算法处理节点数目与具体示例列为表格，表格中-1表示空格，如下：</p><table><thead><tr><th style=text-align:center>初始状态</th><th style=text-align:center>目标状态</th><th style=text-align:center>广度优先搜索处理节点数目</th><th style=text-align:center>启发式搜索处理节点数目</th></tr></thead><tbody><tr><td style=text-align:center>2 8 31 -1 47 6 5</td><td style=text-align:center>1 2 38 -1 47 6 5</td><td style=text-align:center>37</td><td style=text-align:center>10</td></tr><tr><td style=text-align:center>1 2 34 5 67 8 -1</td><td style=text-align:center>1 2 3-1 4 67 5 8</td><td style=text-align:center>25</td><td style=text-align:center>8</td></tr><tr><td style=text-align:center>2 8 31 6 47 -1 5</td><td style=text-align:center>1 2 38 -1 47 6 5</td><td style=text-align:center>61</td><td style=text-align:center>12</td></tr></tbody></table><p>可见，在采用了启发式搜索后，搜索到解时所处理的节点大大减少，说明启发式搜索算法提供了更强的性能。</p><h1 id=总结>总结</h1><p>本文实现了两种算法：广度优先搜索与启发式搜索，求解重排九宫问题。每种算法都通过多个示例验证了代码的可行性。此外，也通过一些示例的比较，发现采用广度优先搜索算法是盲目搜索的，会处理许多不必要的状态，影响算法的性能。而采用曼哈顿距离作为启发式函数的启发式搜索会优先选择更可能抵达目标节点的状态，减少了冗余状态的处理，有效改善算法的性能。</p><h1 id=可能的改进方向>可能的改进方向</h1><p>本文实现了广度优先搜索算法与启发式搜索算法，在这个基础上可以有两种易于实现的改进方式：
<strong>增添问题无解的判定</strong></p><p>在本文的两种算法中，对于没有解的实例，算法仍然会遍历所有可能的状态（总计181440个），最终依据wait队列为空判断无解，严重影响了算法的效率。
对于重排九宫问题，可直接通过以下方式判断是否有解：</p><ul><li><p>计算逆序数：对于数组中的每一对数字 𝑎𝑖和 𝑎𝑗​，如果 𝑖&lt;𝑗且 𝑎𝑖>𝑎𝑗，则该对元素形成一个逆序。逆序数就是这样所有逆序对的总数。</p></li><li><p>判断是否有解：</p><ul><li>如果逆序数是偶数，则该排列是可解的；</li><li>如果逆序数是奇数，则该排列是不可解的。</li></ul></li></ul><p><strong>使用更优越的启发式函数</strong>
在某些情况下，曼哈顿距离可能低估了某些状态之间的实际距离，特别是当数字移动的过程中可能会有较多的交换时。可以考虑使用以下启发式函数，可能会有更好的性能：</p><ol><li><p>错位数（Misplaced Tiles）
错位数启发式计算的是当前状态与目标状态中不同的数字的数量。也就是说，计算当前状态中与目标状态不一致的数字个数。
错位数的定义：
错位数启发式的值是当前状态与目标状态不一致的数字个数，通常是通过比较两个状态中的数字来计算。</p><ul><li>优点：
计算非常简便，适合快速实现。</li><li>缺点：
错位数不能很好地反映某些状态之间的实际“距离”，因此可能不如曼哈顿距离有效，尤其是在需要考虑多个数字交换的情况时。</li></ul></li><li><p>线性冲突（Linear Conflict）
线性冲突是一种在曼哈顿距离的基础上进一步优化的启发式函数。线性冲突发生在两个数字处于同一行或列，并且它们的目标位置是互相对调的。在这种情况下，这两个数字必须交换位置，这增加了额外的代价。
线性冲突的定义：</p><ul><li>线性冲突是在同一行或同一列上的两个数字，它们的位置与目标状态中的位置互相对调。</li><li>每个线性冲突会为启发式函数增加 2 的值（因为每个冲突的解决需要两步）。</li></ul></li></ol><h1 id=源代码>源代码</h1><p>/include/Astar.h</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#ifndef ASTAR_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define ASTAR_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;./Node.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;BFS.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pNode</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> node;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> depth;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cost;
</span></span><span style=display:flex><span>    pNode()<span style=color:#f92672>:</span> node(<span style=color:#66d9ef>nullptr</span>), depth(<span style=color:#ae81ff>0</span>), cost(<span style=color:#ae81ff>0</span>) {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ComparePNode</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> pNode<span style=color:#f92672>&amp;</span> p1, <span style=color:#66d9ef>const</span> pNode<span style=color:#f92672>&amp;</span> p2) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> p1.cost <span style=color:#f92672>&gt;</span> p2.cost;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Astar</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> BFS
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> positions;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Astar(<span style=color:#75715e>/* args */</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FindPath</span>() <span style=color:#66d9ef>override</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>ManhattanDistance</span>(Node<span style=color:#f92672>&amp;</span> node);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span></code></pre></div><p>/include/BFS.h</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#ifndef BFS_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BFS_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;./Node.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BFS</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Node head;
</span></span><span style=display:flex><span>    Node target;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> path;
</span></span><span style=display:flex><span>    set<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> used;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    BFS(<span style=color:#75715e>/* args */</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FindPath</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Print</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>NotUsed</span>(Node<span style=color:#f92672>&amp;</span> node);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span></code></pre></div><p>/include/Node.h</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#ifndef NODE_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define NODE_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>  </span><span style=color:#75715e>// 包含输入输出流
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;optional&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ROW 3
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define COL 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> content[ROW][COL]; <span style=color:#75715e>// 数据成员
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> r;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c;
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> parent;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 构造函数声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Node();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 成员函数声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_value</span>(<span style=color:#66d9ef>int</span> row, <span style=color:#66d9ef>int</span> col, <span style=color:#66d9ef>int</span> value, Node<span style=color:#f92672>*</span> p<span style=color:#f92672>=</span><span style=color:#66d9ef>nullptr</span>);
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> <span style=color:#a6e22e>up</span>();
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> <span style=color:#a6e22e>left</span>();
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> <span style=color:#a6e22e>right</span>();
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> <span style=color:#a6e22e>down</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>==</span>(<span style=color:#66d9ef>const</span> Node<span style=color:#f92672>&amp;</span> other) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>!=</span>(<span style=color:#66d9ef>const</span> Node<span style=color:#f92672>&amp;</span> other) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>const</span> Node<span style=color:#f92672>&amp;</span> other) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// NODE_H
</span></span></span></code></pre></div><p>/src/Astar.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;Astar.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;utility&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>Astar<span style=color:#f92672>::</span>Astar()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    positions.resize(ROW <span style=color:#f92672>*</span> COL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ROW; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> COL;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (target.content[i][j] <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                positions[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> make_pair(i, j);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            positions[target.content[i][j]] <span style=color:#f92672>=</span> make_pair(i, j);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Astar<span style=color:#f92672>::</span>FindPath()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    priority_queue<span style=color:#f92672>&lt;</span>pNode, vector<span style=color:#f92672>&lt;</span>pNode<span style=color:#f92672>&gt;</span>, ComparePNode<span style=color:#f92672>&gt;</span> wait;
</span></span><span style=display:flex><span>    pNode h;
</span></span><span style=display:flex><span>    h.node <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>head;
</span></span><span style=display:flex><span>    h.depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    h.cost <span style=color:#f92672>=</span> ManhattanDistance(head) <span style=color:#f92672>+</span> h.depth;
</span></span><span style=display:flex><span>    wait.emplace(h);
</span></span><span style=display:flex><span>    used.insert(head);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>wait.empty())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        pNode c <span style=color:#f92672>=</span> wait.top();
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> c.node;
</span></span><span style=display:flex><span>        wait.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>curr <span style=color:#f92672>==</span> target)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            path.emplace_back(<span style=color:#f92672>*</span>curr);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (path.back().<span style=color:#66d9ef>operator</span><span style=color:#f92672>!=</span>(head))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                path.emplace_back(<span style=color:#f92672>*</span>(path.back().parent));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>up();
</span></span><span style=display:flex><span>        pNode newpNode;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            newpNode.depth <span style=color:#f92672>=</span> c.depth<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            newpNode.cost <span style=color:#f92672>=</span> ManhattanDistance(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>+</span> newpNode.depth;
</span></span><span style=display:flex><span>            newpNode.node <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>            wait.emplace(newpNode);
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>left();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            newpNode.depth <span style=color:#f92672>=</span> c.depth<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            newpNode.cost <span style=color:#f92672>=</span> ManhattanDistance(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>+</span> newpNode.depth;
</span></span><span style=display:flex><span>            newpNode.node <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>            wait.emplace(newpNode);
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>right();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            newpNode.depth <span style=color:#f92672>=</span> c.depth<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            newpNode.cost <span style=color:#f92672>=</span> ManhattanDistance(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>+</span> newpNode.depth;
</span></span><span style=display:flex><span>            newpNode.node <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>            wait.emplace(newpNode);
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>down();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            newpNode.depth <span style=color:#f92672>=</span> c.depth<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            newpNode.cost <span style=color:#f92672>=</span> ManhattanDistance(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>+</span> newpNode.depth;
</span></span><span style=display:flex><span>            newpNode.node <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>            wait.emplace(newpNode);
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> Astar<span style=color:#f92672>::</span>ManhattanDistance(Node <span style=color:#f92672>&amp;</span>node)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cost <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ROW; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;</span>COL;j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> curr <span style=color:#f92672>=</span> node.content[i][j];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (curr <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            cost <span style=color:#f92672>+=</span> abs(i <span style=color:#f92672>-</span> positions[curr].first) <span style=color:#f92672>+</span> abs(j <span style=color:#f92672>-</span> positions[curr].second);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cost;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>/src/BFS.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;BFS.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;optional&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>BFS<span style=color:#f92672>::</span>BFS()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;请输入初始节点状态&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ROW; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> COL; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> value;
</span></span><span style=display:flex><span>            cin<span style=color:#f92672>&gt;&gt;</span>value;
</span></span><span style=display:flex><span>            head.set_value(i, j, value);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;请输入目标节点状态&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ROW; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> COL; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> value;
</span></span><span style=display:flex><span>            cin<span style=color:#f92672>&gt;&gt;</span>value;
</span></span><span style=display:flex><span>            target.set_value(i, j, value);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> BFS<span style=color:#f92672>::</span>FindPath()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    queue<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>*&gt;</span> wait;
</span></span><span style=display:flex><span>    wait.emplace(<span style=color:#f92672>&amp;</span>head);
</span></span><span style=display:flex><span>    used.insert(head);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>wait.empty())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> wait.front();
</span></span><span style=display:flex><span>        wait.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>curr <span style=color:#f92672>==</span> target)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            path.emplace_back(<span style=color:#f92672>*</span>curr);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (path.back().<span style=color:#66d9ef>operator</span><span style=color:#f92672>!=</span>(head))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                path.emplace_back(<span style=color:#f92672>*</span>(path.back().parent));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>up();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            wait.emplace(temp);
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>left();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>            wait.emplace(temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>right();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>            wait.emplace(temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        temp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>down();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (temp <span style=color:#f92672>&amp;&amp;</span> used.count(<span style=color:#f92672>*</span>temp) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            used.insert(<span style=color:#f92672>*</span>temp);
</span></span><span style=display:flex><span>            wait.emplace(temp);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> BFS<span style=color:#f92672>::</span>Print()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;处理节点数目：&#34;</span><span style=color:#f92672>&lt;&lt;</span>used.size()<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (path.empty())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;没有从初始节点到目标节点的路径&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> path.size()<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>--</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        path[i].print();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; </span><span style=color:#ae81ff>\u2193</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> BFS<span style=color:#f92672>::</span>NotUsed(Node <span style=color:#f92672>&amp;</span>node)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>/src/main.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;../include/BFS.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;../include/Node.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;Astar.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    BFS solution;
</span></span><span style=display:flex><span>    solution.FindPath();
</span></span><span style=display:flex><span>    solution.Print();
</span></span><span style=display:flex><span>    Astar solution2;
</span></span><span style=display:flex><span>    solution2.FindPath();
</span></span><span style=display:flex><span>    solution2.Print();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>/src/Node.cpp</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;../include/Node.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>  </span><span style=color:#75715e>// 用于 memset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;Node.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 构造函数定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Node<span style=color:#f92672>::</span>Node() 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    memset(content, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(content));
</span></span><span style=display:flex><span>    parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// print 函数定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> Node<span style=color:#f92672>::</span>print() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ROW; i<span style=color:#f92672>++</span>) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> COL; j<span style=color:#f92672>++</span>) 
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (content[i][j] <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> content[i][j] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// std::cout &lt;&lt; std::endl;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// set_value 函数定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> Node<span style=color:#f92672>::</span>set_value(<span style=color:#66d9ef>int</span> row, <span style=color:#66d9ef>int</span> col, <span style=color:#66d9ef>int</span> value, Node<span style=color:#f92672>*</span> p) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (row <span style=color:#f92672>&lt;</span> ROW <span style=color:#f92672>&amp;&amp;</span> row <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> col <span style=color:#f92672>&lt;</span> COL <span style=color:#f92672>&amp;&amp;</span> col <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (value <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> row;
</span></span><span style=display:flex><span>            c <span style=color:#f92672>=</span> col;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        content[row][col] <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>    } 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cerr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;索引超出界限&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    parent <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Node<span style=color:#f92672>*</span> Node<span style=color:#f92672>::</span>up()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (r<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>parent <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>parent<span style=color:#f92672>-&gt;</span>r <span style=color:#f92672>==</span> r<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>content[r][c] <span style=color:#f92672>=</span> newNode<span style=color:#f92672>-&gt;</span>content[r<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][c];
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>content[r<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][c] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>r <span style=color:#f92672>=</span> r<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>c <span style=color:#f92672>=</span> c;
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> newNode;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Node<span style=color:#f92672>*</span> Node<span style=color:#f92672>::</span>left()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (c<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>parent <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>parent<span style=color:#f92672>-&gt;</span>c <span style=color:#f92672>==</span> c<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>content[r][c] <span style=color:#f92672>=</span> newNode<span style=color:#f92672>-&gt;</span>content[r][c<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>content[r][c<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>r <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>c <span style=color:#f92672>=</span> c<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> newNode;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Node<span style=color:#f92672>*</span> Node<span style=color:#f92672>::</span>right()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (c<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> COL)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>parent <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>parent<span style=color:#f92672>-&gt;</span>c <span style=color:#f92672>==</span> c<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>content[r][c] <span style=color:#f92672>=</span> newNode<span style=color:#f92672>-&gt;</span>content[r][c<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>content[r][c<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>r <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>c <span style=color:#f92672>=</span> c<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> newNode;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Node<span style=color:#f92672>*</span> Node<span style=color:#f92672>::</span>down()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (r<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> ROW)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>parent <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>parent<span style=color:#f92672>-&gt;</span>r <span style=color:#f92672>==</span> r<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>*</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>content[r][c] <span style=color:#f92672>=</span> newNode<span style=color:#f92672>-&gt;</span>content[r<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][c];
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>content[r<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][c] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>r <span style=color:#f92672>=</span> r<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>c <span style=color:#f92672>=</span> c;
</span></span><span style=display:flex><span>        newNode<span style=color:#f92672>-&gt;</span>parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> newNode;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> Node<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>==</span>(<span style=color:#66d9ef>const</span> Node <span style=color:#f92672>&amp;</span>other) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ROW; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> COL; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (content[i][j] <span style=color:#f92672>!=</span> other.content[i][j])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> Node<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>!=</span>(<span style=color:#66d9ef>const</span> Node <span style=color:#f92672>&amp;</span>other) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ROW; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> COL; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (content[i][j] <span style=color:#f92672>!=</span> other.content[i][j])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> Node<span style=color:#f92672>::</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>const</span> Node<span style=color:#f92672>&amp;</span> other) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ROW; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> COL; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (content[i][j] <span style=color:#f92672>!=</span> other.content[i][j])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> content[i][j] <span style=color:#f92672>&lt;</span> other.content[i][j];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>/CMakeLists.txt</p><pre tabindex=0><code class=language-CMakeLists data-lang=CMakeLists># 设置CMake的最低版本要求
cmake_minimum_required(VERSION 3.10)

# 设置项目名称
project(MyProject VERSION 1.0 LANGUAGES CXX)

# 设置C++标准
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 设置生成的二进制文件目录
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)

# 设置中间目标文件目录
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

# 包含头文件目录
include_directories(${CMAKE_SOURCE_DIR}/include)

# 如果有第三方库，可以指定库路径
# link_directories(${CMAKE_SOURCE_DIR}/lib)

# 定义源文件
set(SOURCE_FILES
    src/main.cpp
    src/BFS.cpp
    src/Node.cpp
    src/Astar.cpp
)

set(HEADERS
    include/BFS.h
    include/Node.h
    include/Astar.h
)

# 定义可执行文件
add_executable(MyProject ${SOURCE_FILES} ${HEADERS})
</code></pre></div><div class=post-footer></div></article></main></body></html>