<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Yuaay</title><link>https://xiongyuaay.github.io/posts/</link><description>Recent content in Posts on Yuaay</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 12 Nov 2024 18:20:52 +0800</lastBuildDate><atom:link href="https://xiongyuaay.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>2021B_1--Rapid Bushfire Response for Emergency Response</title><link>https://xiongyuaay.github.io/posts/thesis/2021b_1/</link><pubDate>Tue, 12 Nov 2024 18:20:52 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/thesis/2021b_1/</guid><description>&lt;h1 id="rapid-bushfire-response-for-emergency-response">Rapid Bushfire Response for Emergency Response&lt;/h1>
&lt;p>使用到的模型：&lt;/p>
&lt;ul>
&lt;li>AHP层次分析法
&lt;ul>
&lt;li>用来确定victoria不同地区发生火灾的危险程度&lt;/li>
&lt;li>也可以结合模糊评价的方法，得到最终的评判结果&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于贪心算法的无线电中继无人机数量位置确定方法
&lt;ul>
&lt;li>论文中首先假设每一个需要防范的地区初始时可以部署中继无人机的范围&lt;/li>
&lt;li>根据不同地区中继无人机的部署范围求交，&lt;/li>
&lt;li>得到服务最多SSA无人机的中继无人机部署范围，&lt;/li>
&lt;li>每次选取复用率最大的，同时删除已经被服务的区域&lt;/li>
&lt;li>如此直到所有区域都被服务&lt;/li>
&lt;li>&lt;strong>本质上是根据确定了的SSA无人机分布与数量确定中继无人机的部署&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>三元可匹配预测模型
&lt;ul>
&lt;li>根据过去特殊事件的发生来预测未来特殊事件的发生&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SPM信号衰减模型
&lt;ul>
&lt;li>完善任务一所建立的模型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>阅读论文想法&lt;/strong>
在这篇论文中，我认为有以下几点值得注意：&lt;/p>
&lt;ul>
&lt;li>对任务目标的确定
&lt;ul>
&lt;li>论文中首先明确了SSA无人机是用以监视可能发生火灾的区域，而并非只在火灾发生时提供支持（在阅读题目过程中我对此有所误解）&lt;/li>
&lt;li>在论文中简化了部分问题，如不考虑比较小的火灾、在任务一的建立过程中没有过于考虑地形等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>任务目标的细化
&lt;ul>
&lt;li>将整个区域分类，针对不同区域分别考虑，简化了问题&lt;/li>
&lt;li>分开考虑SSA无人机与中继无人机，更易于模型的建立&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>chat给出的三元可匹配模型示例&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/364574038403923.png" alt="1">&lt;/p>
&lt;p>​&lt;img src="https://xiongyuaay.github.io/images/550871063099798.png" alt="2">&lt;/p></description></item><item><title>操作系统实验二 进程通信与内存管理</title><link>https://xiongyuaay.github.io/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Tue, 12 Nov 2024 17:46:10 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>&lt;h1 id="进程的软中断通信">进程的软中断通信&lt;/h1>
&lt;h2 id="查看帮助手册">查看帮助手册&lt;/h2>
&lt;h3 id="fork系统调用">fork系统调用&lt;/h3>
&lt;p>使用man命令查看fork系统调用结果如下图：&lt;/p>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/377594525772505.png" alt="1">&lt;/p>
&lt;p>可见结果显示没有相应的条目，猜测可能没有安装man帮助手册，通过以下资料查阅安装man手册。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/weixin_61939442/article/details/142136016#:~:text=Man%20%E6%89%8B%E5%86%8C%E5%AE%89%E8%A3%851.%E9%85%8D%E7%BD%AEman%20%5Broot%40myEuler%20~%5D%23%20dnf%20-y%20install%20man,https%3A%2F%2Fmirrors.edge.kernel.org%2Fpub%2Flinux%2Fdocs%2Fman-pages%2Fman-pages-6.03.tar.gz%20%5Broot%40myEuler%20~%5D%23%20tar%20-xzvf%20man-pages-6.03.tar.gz4.%E5%AE%89%E8%A3%85man%E6%89%8B%E5%86%8C%23%E8%BF%9B%E5%85%A5%E7%9B%AE%E6%A0%87%E7%9B%AE%E5%BD%95%20%5Br_openeuler%20man%E6%89%8B%E5%86%8C%E5%AE%89%E8%A3%85">man手册安装&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>使用的安装命令及结果如下图：&lt;br>
&lt;img src="https://xiongyuaay.github.io/images/443453311011602.png" alt="2">&lt;/p>
&lt;p>可见在安装好man手册，成功使用man fork命令，如下图：
&lt;img src="https://xiongyuaay.github.io/images/167935907718258.png" alt="">&lt;/p>
&lt;h3 id="kill系统调用">kill系统调用&lt;/h3>
&lt;p>结果如下图：&lt;br>
&lt;img src="https://xiongyuaay.github.io/images/344455056047998.png" alt="">&lt;/p>
&lt;h3 id="signal系统调用">signal系统调用&lt;/h3>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/116624541508.png" alt="">&lt;/p>
&lt;h3 id="sleep系统调用">sleep系统调用&lt;/h3>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/427004511623406.png" alt="">&lt;/p>
&lt;h3 id="exit系统调用">exit系统调用&lt;/h3>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/62306574070474.png" alt="">&lt;/p>
&lt;h2 id="软中断程序">软中断程序&lt;/h2>
&lt;p>openEuler系统下，使用命令kill -l查看所有信号及其编号的结果如下：
&lt;img src="https://xiongyuaay.github.io/images/24568132916712.png" alt="">&lt;/p>
&lt;p>补充完成进程软中断的程序代码如下，其中对于等待时间的要求，考虑到sleep过程可以被信号打断，选择通过sleep函数实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/wait.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;signal.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pid_t&lt;/span> pid1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, pid2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">inter_handler&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> signum) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用 kill() 发送整数值为 16 和 17 的信号
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (pid1 &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#a6e22e">kill&lt;/span>(pid1, &lt;span style="color:#ae81ff">16&lt;/span>); &lt;span style="color:#75715e">// 发送信号 16 给子进程1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (pid2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#a6e22e">kill&lt;/span>(pid2, &lt;span style="color:#ae81ff">17&lt;/span>); &lt;span style="color:#75715e">// 发送信号 17 给子进程2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Parent received signal %d, sending signals 16 and 17 to child processes&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, signum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">waiting&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> signum) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Child process received signal %d, exiting...&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, signum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">exit&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建子进程1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> (pid1 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) pid1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fork&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pid1 &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建子进程2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> (pid2 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) pid2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fork&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pid2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 父进程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signal&lt;/span>(SIGINT, inter_handler); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">signal&lt;/span>(SIGQUIT, inter_handler); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wait&lt;/span>(NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wait&lt;/span>(NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">Parent process is killed!!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 子进程2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signal&lt;/span>(&lt;span style="color:#ae81ff">17&lt;/span>, waiting); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sleep&lt;/span>(&lt;span style="color:#ae81ff">5&lt;/span>); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">Child process 2 is waiting for signal 17...&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 子进程1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signal&lt;/span>(&lt;span style="color:#ae81ff">16&lt;/span>, waiting); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sleep&lt;/span>(&lt;span style="color:#ae81ff">5&lt;/span>); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">Child process 1 is waiting for signal 16...&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>分别在5s内进行操作和不进行操作，编译运行结果如下：&lt;/p></description></item><item><title>数学建模 灰色关联分析（一点感悟）</title><link>https://xiongyuaay.github.io/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</link><pubDate>Sat, 09 Nov 2024 19:08:32 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</guid><description>&lt;h1 id="灰色关联分析">灰色关联分析&lt;/h1>
&lt;p>灰色关联分析用以分析影响目标的主要因素&lt;/p>
&lt;p>其中，用以分析的数据类型为序列形式，
需要确定原因的序列为母序列
需要衡量影响程度的为子序列
使用步骤：&lt;/p>
&lt;ul>
&lt;li>将所有序列全部标准化&lt;/li>
&lt;li>将母序列与子序列两两相减，计算两极最大差和两级最小差&lt;/li>
&lt;li>对每个元素计算灰色关联系数&lt;/li>
&lt;li>将灰色关联系数求平均值得到灰色关联度&lt;/li>
&lt;li>根据灰色关联度的大小下结论&lt;/li>
&lt;/ul>
&lt;p>部分使用到的公式如下：&lt;br>
&lt;img src="https://xiongyuaay.github.io/images/443974856105592.png" alt="1">
&lt;img src="https://xiongyuaay.github.io/images/544484652480945.png" alt="2">
&lt;img src="https://xiongyuaay.github.io/images/53064102515680.png" alt="3">&lt;/p></description></item><item><title>数学建模 Topsis（一点感悟）</title><link>https://xiongyuaay.github.io/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--topsis%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</link><pubDate>Sat, 09 Nov 2024 19:08:21 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--topsis%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</guid><description>&lt;h1 id="topsis">Topsis&lt;/h1>
&lt;p>本质上是针对多个指标，通过与最优解与最劣解间的距离来得到某个方案的评分&lt;/p>
&lt;p>可以很好的得到每个方案间的差距&lt;/p>
&lt;p>使用步骤：&lt;/p>
&lt;ul>
&lt;li>得到不同方案在不同指标的数据&lt;/li>
&lt;li>将同一指标不同方案的值正向化&lt;/li>
&lt;li>对得到的数据标准化，消除量纲的影响&lt;/li>
&lt;li>得到针对于这些指标的最优解与最劣解&lt;/li>
&lt;li>根据最优解与最劣解得到每个方案的评分
&lt;ul>
&lt;li>&lt;strong>注意，如果每个指标的重要程度不一样，可以先通过其他赋予权值方法得到权重，将权重与距离求解结合，得到评分&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>计算最优解、最劣解的公式：
&lt;img src="https://xiongyuaay.github.io/images/337922171116636.png" alt="1">
带权重的计算公式：
&lt;img src="https://xiongyuaay.github.io/images/533552640375792.png" alt="2">&lt;/p></description></item><item><title>数学建模 熵权法（一点感悟）</title><link>https://xiongyuaay.github.io/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E7%86%B5%E6%9D%83%E6%B3%95%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</link><pubDate>Sat, 09 Nov 2024 19:08:10 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E7%86%B5%E6%9D%83%E6%B3%95%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</guid><description>&lt;h1 id="熵权法">熵权法&lt;/h1>
&lt;p>一种基于数据本身的客观的赋予权重的方法
利用信息熵，衡量了掌握信息的确切程度
&lt;strong>值得注意的是，这种信息熵是基于方案的而不是基于指标。衡量了所有方案在这个指标的信息掌握程度。&lt;/strong>&lt;/p>
&lt;p>最终的权重衡量这个指标距离理想情况的重要程度，
我认为，最好在所有指标都很重要、且每种指标重要程度差不多的情况下使用&lt;/p>
&lt;p>使用步骤&lt;/p>
&lt;ul>
&lt;li>得到影响最终决策的因素（指标）&lt;/li>
&lt;li>得到不同方案在这些因素的值&lt;/li>
&lt;li>将这些值按指标正向化
&lt;ul>
&lt;li>极大型指标&lt;/li>
&lt;li>中间型指标&lt;/li>
&lt;li>极小型指标&lt;/li>
&lt;li>区间型指标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将这些指标按列标准化&lt;/li>
&lt;li>对每一个指标计算信息熵
&lt;ul>
&lt;li>&lt;strong>注意，这里使用的是改进了的公式，方便之后计算权重&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>根据信息熵得到权重&lt;/li>
&lt;/ul>
&lt;p>计算信息熵时所用公式：&lt;br>
&lt;img src="https://xiongyuaay.github.io/images/222104284080536.png" alt="1">&lt;/p>
&lt;p>标准化时可以用到的一些示例方法：&lt;br>
&lt;img src="https://xiongyuaay.github.io/images/587765196388639.png" alt="2">&lt;/p></description></item><item><title>数学建模 模糊评价（一点感悟）</title><link>https://xiongyuaay.github.io/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E6%A8%A1%E7%B3%8A%E8%AF%84%E4%BB%B7%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</link><pubDate>Sat, 09 Nov 2024 19:08:01 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E6%A8%A1%E7%B3%8A%E8%AF%84%E4%BB%B7%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</guid><description>&lt;h1 id="模糊评价">模糊评价&lt;/h1>
&lt;p>对某一个对象，有一个总的评判结果，
可以将这个评判结果作为一个集合
如{优， 良， 差}等&lt;/p>
&lt;p>目前已知影响这个对象的一些因素的实际值
&lt;strong>注意：这些实际值都只是单个值&lt;/strong>&lt;/p>
&lt;p>根据这些因素的实际意义，给出这些因素相对于不同评语的隶属函数
&lt;strong>由F分布得到隶属函数&lt;/strong>
&lt;img src="https://xiongyuaay.github.io/images/146262814940887.png" alt="隶属函数">
从而可以得到这些因素对不同评语的隶属度&lt;/p>
&lt;p>对这些因素之间，可以通过其他方法，&lt;strong>如：层次分析法、熵权法等&lt;/strong>，确定对总体研究对象的权重，
借由这些权重，可以得到该总体对象在这个评语集的隶属度，
最后，根据隶属度，选择最高的可以判断该对象属于哪一个层次。&lt;/p>
&lt;p>可以用以离散化的评价，结果为评语集的不同隶属度。&lt;/p></description></item><item><title>数学建模 层次分析法（一点感悟）</title><link>https://xiongyuaay.github.io/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</link><pubDate>Sat, 09 Nov 2024 18:47:27 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</guid><description>&lt;h1 id="ahp">AHP&lt;/h1>
&lt;p>主观赋值评价方法，多指标&lt;/p>
&lt;ul>
&lt;li>构造判断矩阵&lt;/li>
&lt;li>利用判断矩阵计算权重&lt;/li>
&lt;li>判断一致性是否通过&lt;/li>
&lt;li>得到该层相对于上一层的权重&lt;/li>
&lt;li>最底层可直接将该层权重作为其相对与上一层指标的得分&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>具体计算权重与一致性公式使用时查阅&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/111586079287530.png" alt="santy赋值">&lt;/p>
&lt;h2 id="流程">流程&lt;/h2>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/568745427628904.png" alt="流程图">&lt;/p></description></item></channel></rss>