<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on yuaay</title><link>https://xiongyuaay.github.io/posts/</link><description>Recent content in Posts on yuaay</description><generator>Hugo</generator><language>en</language><lastBuildDate>Wed, 04 Dec 2024 17:29:50 +0800</lastBuildDate><atom:link href="https://xiongyuaay.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>重排九宫</title><link>https://xiongyuaay.github.io/posts/ai/%E9%87%8D%E6%8E%92%E4%B9%9D%E5%AE%AB/</link><pubDate>Wed, 04 Dec 2024 17:29:50 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/ai/%E9%87%8D%E6%8E%92%E4%B9%9D%E5%AE%AB/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>重排九宫就是重新排列九宫图的意思。这是根据当时盛行研究的数学游戏——纵横图（也叫幻方或魔方阵）发展来的，九宫游戏的起源，更可追溯到我国远古神话历史时代的河图、洛书。重排九宫则属滑块类游戏。在使用算术的同时，还必须推动方块使其到相对应的位置。其玩法是在3×3方格盘上，放有1-8八个数，剩下一格为空，每一空格其周围的数字可移至空格。先设定初始排列数字，然后开始思考如何以最少的移动次数来达到目的排列状态。&lt;/p>
&lt;p>目前，针对该问题的一般解法为广度优先搜索。对于某一个确定的初始状态和目标状态，通过广度优先的方式，遍历所有的可能性，最终找到一条从初始状态到目标状态的路径，或者无解。&lt;/p>
&lt;p>此外，由于广度优先是盲目搜索的，也可以结合启发式算法，如A*算法，在广度优先搜索的基础上，加入一个启发式函数来优化搜索过程，最终常常可以减少找到解时所生成的节点数量，增强算法的性能。&lt;/p>
&lt;h1 id="摘要">摘要&lt;/h1>
&lt;p>本文结合广度优先搜索的思想，编写C++代码成功实现了重排九宫问题的计算机求解。对于任意的初始状态及目的状态，如果有解，代码会输出从初始状态到目标状态最短路径。&lt;/p>
&lt;p>此外，在尝试使用多个示例时，本文也发现使用广度优先搜索的重排九宫算法对某些目标状态的求解产生了大量不必要的节点。在查阅相关资料后，本文在广度优先搜索的基础上，结合了A*算法等启发式思想，成功改进了相关算法，能够在大部分情况下，更好的求解重排九宫问题。&lt;/p>
&lt;h1 id="算法描述">算法描述&lt;/h1>
&lt;h2 id="广度优先搜索">广度优先搜索&lt;/h2>
&lt;h3 id="算法">算法&lt;/h3>
&lt;p>将九宫格的每一种可能的摆放方式定义为九宫格的一种状态。初始时，程序读入用户输入的初始状态与目标状态，分别存储在head和target结构中。之后，对于每一次程序执行，定义队列wait表示等待处理的状态，定义集合used表示已经处理过的状态，防止重复处理。在算法正式执行前，将head节点置入wait队列，used清零。&lt;/p>
&lt;p>之后，从wait队列中取出状态，如果该状态为目标状态，算法结束，找到路径；如果该状态不是目标状态，将经由该状态可以抵达、且不再used集合中的状态加入wait队列及used集合。然后，重复从wait队列取出状态进行判断，直到找到目标状态或者wait队列为空时，算法结束。&lt;/p>
&lt;h3 id="程序结构">程序结构&lt;/h3>
&lt;p>项目文件结构如下：
📦root
┣ 📂include
┃ ┣ 📜BFS.h
┃ ┗ 📜Node.h
┣ 📂src
┃ ┣ 📜BFS.cpp
┃ ┣ 📜Node.cpp
┃ ┗ 📜main.cpp
┣ 📜CMakeLists.txt
┣ 📜LICENSE
┗ 📜README.md&lt;/p>
&lt;p>其中，在Node.h文件中定义了表示九宫格状态的结构体struct Node,代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> content[ROW][COL]; &lt;span style="color:#75715e">// 数据成员
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> r;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#f92672">*&lt;/span> parent;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 构造函数声明
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Node();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 成员函数声明
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">set_value&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> row, &lt;span style="color:#66d9ef">int&lt;/span> col, &lt;span style="color:#66d9ef">int&lt;/span> value, Node&lt;span style="color:#f92672">*&lt;/span> p&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">nullptr&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">up&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">left&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">right&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">down&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">==&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Node&lt;span style="color:#f92672">&amp;amp;&lt;/span> other) &lt;span style="color:#66d9ef">const&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">!=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Node&lt;span style="color:#f92672">&amp;amp;&lt;/span> other) &lt;span style="color:#66d9ef">const&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Node&lt;span style="color:#f92672">&amp;amp;&lt;/span> other) &lt;span style="color:#66d9ef">const&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>content表示该状态内容，r、c表示空格所在位置，parent是指向生成该状态的父状态。对于==、！=、&amp;lt;则定义了忽略父节点指针的重载运算。&lt;/p></description></item><item><title>LeetCode--新增道路查询后的最短距离2</title><link>https://xiongyuaay.github.io/posts/leetcode/leetcode--%E6%96%B0%E5%A2%9E%E9%81%93%E8%B7%AF%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB2/</link><pubDate>Thu, 21 Nov 2024 22:49:59 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/leetcode/leetcode--%E6%96%B0%E5%A2%9E%E9%81%93%E8%B7%AF%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB2/</guid><description>&lt;h1 id="问题描述">问题描述&lt;/h1>
&lt;p>给你一个整数 n 和一个二维整数数组 queries。&lt;/p>
&lt;p>有 n 个城市，编号从 0 到 n - 1。初始时，每个城市 i 都有一条单向道路通往城市 i + 1（ 0 &amp;lt;= i &amp;lt; n - 1）。&lt;/p>
&lt;p>queries[i] = [ui, vi] 表示新建一条从城市 ui 到城市 vi 的单向道路。每次查询后，你需要找到从城市 0 到城市 n - 1 的最短路径的长度。&lt;/p>
&lt;p>所有查询中不会存在两个查询都满足 queries[i][0] &amp;lt; queries[j][0] &amp;lt; queries[i][1] &amp;lt; queries[j][1]。&lt;/p>
&lt;p>返回一个数组 answer，对于范围 [0, queries.length - 1] 中的每个 i，answer[i] 是处理完前 i + 1 个查询后，从城市 0 到城市 n - 1 的最短路径的长度。&lt;/p>
&lt;p>以下为题目的一个示例：&lt;/p>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/LeetCode--%E6%96%B0%E5%A2%9E%E9%81%93%E8%B7%AF%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB2/image.png" alt="alt text">&lt;/p></description></item><item><title>LeetCode--新增道路查询后的最短距离1</title><link>https://xiongyuaay.github.io/posts/leetcode/leetcode--%E6%96%B0%E5%A2%9E%E9%81%93%E8%B7%AF%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</link><pubDate>Tue, 19 Nov 2024 23:54:11 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/leetcode/leetcode--%E6%96%B0%E5%A2%9E%E9%81%93%E8%B7%AF%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</guid><description>&lt;h1 id="问题描述">问题描述&lt;/h1>
&lt;p>给你一个整数 n 和一个二维整数数组 queries。
有 n 个城市，编号从 0 到 n - 1。初始时，每个城市 i 都有一条单向道路通往城市 i + 1（ 0 &amp;lt;= i &amp;lt; n - 1）。
queries[i] = [ui, vi] 表示新建一条从城市 ui 到城市 vi 的单向道路。每次查询后，你需要找到从城市 0 到城市 n - 1 的最短路径的长度。
返回一个数组 answer，对于范围 [0, queries.length - 1] 中的每个 i，answer[i] 是处理完前 i + 1 个查询后，从城市 0 到城市 n - 1 的最短路径的长度。&lt;/p>
&lt;p>有如下示例：&lt;/p>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/image-2.png" alt="alt text">&lt;/p>
&lt;h1 id="分析">分析&lt;/h1>
&lt;p>面对此题，第一时间考虑的是广度优先搜索，一层一层遍历每一种可能的路径，考虑到每一条路径的权重都是1，最先达到终点的即为最短路径。
此外，考虑到最终的最短路径中，考虑到达终点的前一个节点，从起点到该节点的路径也必须是最短路径，据此可递推得到最终的最短路径，且考虑到在每一次添加数组queries中的边时，只有queries[i][1]及其之后的节点可能被影响，故在每次查询时，也只需重新计算从queries[i][1]之后的节点最短路径。&lt;/p>
&lt;p>但是考虑到该题为最短路径问题，可以使用Dijkstra算法在每一次查询时计算最短路径。此解法并非最优，但这里用这种算法主要用于记录一种DIjkstra算法的C++的实现方式。&lt;/p>
&lt;h1 id="代码">代码&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;queue&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;limits&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Edge&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> weight;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Edge() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Edge(&lt;span style="color:#66d9ef">int&lt;/span> to, &lt;span style="color:#66d9ef">int&lt;/span> weight)&lt;span style="color:#f92672">:&lt;/span> to(to), weight(weight){}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> Graph &lt;span style="color:#f92672">=&lt;/span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Edge&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> shortestDistanceAfterQueries(&lt;span style="color:#66d9ef">int&lt;/span> n, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;amp;&lt;/span> queries) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Graph graph;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> answer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> q_num &lt;span style="color:#f92672">=&lt;/span> queries.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph.resize(n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph[i].emplace_back(i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> q_num; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph[queries[i][&lt;span style="color:#ae81ff">0&lt;/span>]].emplace_back(queries[i][&lt;span style="color:#ae81ff">1&lt;/span>], &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ans &lt;span style="color:#f92672">=&lt;/span> Dijkstra(graph, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> answer.emplace_back(ans);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> answer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">Dijkstra&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Graph&lt;span style="color:#f92672">&amp;amp;&lt;/span> graph, &lt;span style="color:#66d9ef">int&lt;/span> start)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> graph.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> dist(n, __INT_MAX__);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dist[start] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// &amp;lt;distance, destination&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>, greater&lt;span style="color:#f92672">&amp;lt;&amp;gt;&amp;gt;&lt;/span> pq;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pq.emplace(&lt;span style="color:#ae81ff">0&lt;/span>, start);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pq.empty())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> [curr_dist, curr_vertex] &lt;span style="color:#f92672">=&lt;/span> pq.top();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pq.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(curr_dist &lt;span style="color:#f92672">&amp;gt;&lt;/span> dist[curr_vertex]) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Edge&lt;span style="color:#f92672">&amp;amp;&lt;/span> edge:graph[curr_vertex])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> new_dist &lt;span style="color:#f92672">=&lt;/span> edge.weight &lt;span style="color:#f92672">+&lt;/span> curr_dist;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(new_dist &lt;span style="color:#f92672">&amp;lt;&lt;/span> dist[edge.to])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dist[edge.to] &lt;span style="color:#f92672">=&lt;/span> new_dist;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pq.emplace(new_dist, edge.to);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> dist.back();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里记录图的结构体、选取最小距离时所用到的优先队列是之前不熟悉的用法，故记录在此。&lt;/p></description></item><item><title>2020A_1--Forecasts for the Ecology and Fisheries Economy of Scottish herring and mackerel</title><link>https://xiongyuaay.github.io/posts/thesis/2020a_1/</link><pubDate>Sun, 17 Nov 2024 20:04:22 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/thesis/2020a_1/</guid><description>&lt;h1 id="问题描述">问题描述&lt;/h1>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>全球海洋温度会影响某些海洋生物物种的栖息地质量。当温度变化太大而无法继续繁衍生息时，这些物种会迁移到更适合它们现在和未来生活和繁殖成功的其他栖息地。该联盟希望更好地了解如果全球海洋温度升高，苏格兰鲱鱼和鲭鱼可能从苏格兰附近的当前栖息地迁移的相关问题。这两种鱼种代表了对苏格兰渔业的重大经济贡献。鲱鱼和鲭鱼种群位置的变化可能会使苏格兰的小型渔业公司在经济上不切实际，这些公司使用没有船上冷藏的渔船来捕捞新鲜鱼并将其运送到苏格兰渔港的市场。&lt;/p>
&lt;h2 id="问题">问题&lt;/h2>
&lt;ul>
&lt;li>构建一个数学模型，以确定未来 50 年这两种鱼类最可能的位置。&lt;/li>
&lt;li>根据海水温度变化的速度，使用您的模型来预测最佳情况、最坏情况和最可能经过的时间，如果小型渔业公司继续在其当前位置运营，这些种群将距离太远，小型渔业公司无法收获。（Based upon how rapidly the ocean water temperature change occurs, use your model to predict best case, worst case, and most likely elapsed time(s) until these populations will be too far away for small ﬁshing companies to harvest if the small ﬁshing companies continue to operate out of their current locations.）&lt;/li>
&lt;li>根据您的预测分析，这些小型渔业公司是否应该改变他们的运营方式？&lt;/li>
&lt;li>使用您的模型来解决如果一部分渔业进入另一个国家的领海（海），您的提案会受到怎样的影响。&lt;/li>
&lt;/ul>
&lt;h1 id="论文思路">论文思路&lt;/h1>
&lt;p>在这篇论文中，作者将这些问题细化，通过一步步的分析原因，给出了每个问题的建模思路。
在建模之前，论文首先收集数据给出了对应海域的平面图，将平面图划分为一个个点域，将原先连续的海域离散化，方便计算机处理与模拟。
对于两种鱼类的位置，论文考虑到题目中影响鱼类迁移的因素为海洋温度，通过收集海域过去的温度变化，得到预测未来海域温度的模型。
之后，从每一条鱼出发，考虑它们在面对海洋不同区域的温度时，选择的迁移方向与速度，并在这个过程中加入随机因素，模拟除温度之外的影响个体迁移方向的因素。
此外，在建模时，个体的迁移变化扩展到某一个区域鱼类密度的变化，通过未来不同时间不同区域的鱼类密度，来体现迁移的结果。&lt;/p>
&lt;p>之后，综合考虑温度变化以及鱼类在未来的每一个时间点的迁移趋势，得到问题一的鱼类位置预测模型
对于问题二，论文建立了小型渔业公司的营收模型，考虑捕鱼船的捕鱼范围、单次航程、捕鱼区域的鱼类密度，可以得到一次捕鱼鱼类收获，之后更具市场价格与花费，得到营收。
根据该营收模型，通过10000次的未来鱼类位置情况模拟，计算出小型渔业公司在最好、最坏、最可能情况下的未来经营情况。&lt;/p>
&lt;p>根据模型结果，则可以给出适当的建议。在问题四中，限制问题三中计算方式，可重新得到结果并给出建议。&lt;/p></description></item><item><title>数学建模 最小费用最大流</title><link>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/</link><pubDate>Fri, 15 Nov 2024 20:50:54 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/</guid><description>&lt;h2 id="什么是最小费用最大流问题">什么是最小费用最大流问题&lt;/h2>
&lt;p>最小费用最大流同样建立在流网络上，可以看作最大流问题的一个拓展。不同的是，在最小费用最大流问题中，每条边同时包含三个属性，即最大流量，当前流量，该条边的费用。&lt;/p>
&lt;p>求解最小费用最大流问题就是要求在一个流网络中求得一种状态，表示一种最大流的结果，并且在所有可能的最大流状态中，该最大流状态所使用的总费用最小。&lt;/p>
&lt;h2 id="求解步骤">求解步骤&lt;/h2>
&lt;p>求解最小费用最大流问题可通过以下步骤实现：&lt;/p>
&lt;ul>
&lt;li>初始化网络，对于所有当前已有负荷的边添加一条费用为该边相反数的反向边，对于当前负荷已达最大负荷的边，从边集合中删除。&lt;/li>
&lt;li>选取流网络中，从源节点到目的节点的一条最小费用路径。&lt;/li>
&lt;li>使用最大流问题中的Ford Fulkerson算法，求得该路径可以增加的负荷&lt;/li>
&lt;li>重新初始化该网络，继续寻找最小费用路径，知道流网络中不存在从源节点到目的节点的路径&lt;/li>
&lt;/ul>
&lt;p>通过这些步骤，便可求得一种最大流状态，且该最大流状态所用费用最小。&lt;/p></description></item><item><title>2021B_1--Rapid Bushfire Response for Emergency Response</title><link>https://xiongyuaay.github.io/posts/thesis/2021b_1/</link><pubDate>Tue, 12 Nov 2024 18:20:52 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/thesis/2021b_1/</guid><description>&lt;h1 id="rapid-bushfire-response-for-emergency-response">Rapid Bushfire Response for Emergency Response&lt;/h1>
&lt;p>使用到的模型：&lt;/p>
&lt;ul>
&lt;li>AHP层次分析法
&lt;ul>
&lt;li>用来确定victoria不同地区发生火灾的危险程度&lt;/li>
&lt;li>也可以结合模糊评价的方法，得到最终的评判结果&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于贪心算法的无线电中继无人机数量位置确定方法
&lt;ul>
&lt;li>论文中首先假设每一个需要防范的地区初始时可以部署中继无人机的范围&lt;/li>
&lt;li>根据不同地区中继无人机的部署范围求交，&lt;/li>
&lt;li>得到服务最多SSA无人机的中继无人机部署范围，&lt;/li>
&lt;li>每次选取复用率最大的，同时删除已经被服务的区域&lt;/li>
&lt;li>如此直到所有区域都被服务&lt;/li>
&lt;li>&lt;strong>本质上是根据确定了的SSA无人机分布与数量确定中继无人机的部署&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>三元可匹配预测模型
&lt;ul>
&lt;li>根据过去特殊事件的发生来预测未来特殊事件的发生&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>SPM信号衰减模型
&lt;ul>
&lt;li>完善任务一所建立的模型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>阅读论文想法&lt;/strong>
在这篇论文中，我认为有以下几点值得注意：&lt;/p>
&lt;ul>
&lt;li>对任务目标的确定
&lt;ul>
&lt;li>论文中首先明确了SSA无人机是用以监视可能发生火灾的区域，而并非只在火灾发生时提供支持（在阅读题目过程中我对此有所误解）&lt;/li>
&lt;li>在论文中简化了部分问题，如不考虑比较小的火灾、在任务一的建立过程中没有过于考虑地形等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>任务目标的细化
&lt;ul>
&lt;li>将整个区域分类，针对不同区域分别考虑，简化了问题&lt;/li>
&lt;li>分开考虑SSA无人机与中继无人机，更易于模型的建立&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>chat给出的三元可匹配模型示例&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/364574038403923.png" alt="1">&lt;/p>
&lt;p>​&lt;img src="https://xiongyuaay.github.io/images/550871063099798.png" alt="2">&lt;/p></description></item><item><title>LeetCode--判断矩形的两个角落是否可达</title><link>https://xiongyuaay.github.io/posts/leetcode/leetcode--%E5%88%A4%E6%96%AD%E7%9F%A9%E5%BD%A2%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A7%92%E8%90%BD%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BE%BE/</link><pubDate>Tue, 12 Nov 2024 17:46:10 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/leetcode/leetcode--%E5%88%A4%E6%96%AD%E7%9F%A9%E5%BD%A2%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A7%92%E8%90%BD%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BE%BE/</guid><description>&lt;p>来记录一下最近写的LeetCode算法题，以免以后遗忘。“判断矩形的两个角落是否可达”是LeetCode上序号为3235的一道困难题，实现起来颇为复杂，现将整个思考解答过程记录如下：&lt;/p>
&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给你两个正整数 xCorner 和 yCorner 和一个二维整数数组 circles ，其中 circles[i] = [xi, yi, ri] 表示一个圆心在 (xi, yi) 半径为 ri 的圆。&lt;/p>
&lt;p>坐标平面内有一个左下角在原点，右上角在 (xCorner, yCorner) 的矩形。你需要判断是否存在一条从左下角到右上角的路径满足：路径 完全 在矩形内部，不会 触碰或者经过 任何 圆的内部和边界，同时 只 在起点和终点接触到矩形。&lt;/p>
&lt;p>如果存在这样的路径，请你返回 true ，否则返回 false 。&lt;/p>
&lt;p>以下是官网给的示例，便于理解题目意思：&lt;/p>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/image.png" alt="alt text">&lt;/p>
&lt;h2 id="解题思路">解题思路&lt;/h2>
&lt;p>分析题目，我认为可以从两个方面去考虑：&lt;/p>
&lt;ul>
&lt;li>找到可以连接矩形两个角落的路径&lt;/li>
&lt;li>证明所有的圆覆盖的区域完全阻塞了可能的路径&lt;/li>
&lt;/ul>
&lt;p>首先从第一个方向思考，要找到可以连接矩形两个角落的路径，可以从起点出发，不断探索可以延申的方向，通过深度搜索或者广度搜索，如果可以探索到一条到达右上角（目的角落）的路径，即说明存在这样的路径，如果遍历完全后，仍然没有可行解，则说明起点与终点之间被完全阻塞了。&lt;/p>
&lt;p>考虑到在进行深度搜索或者广度搜索时，从一个节点出发的下一个节点的可能性是有限的，并且总的节点数目也应该是有限的，这样才能确保搜索到所有可能的路径。&lt;/p>
&lt;p>但是题目中，并没有限制路径的经过节点，这条可能的路径将是可以任意曲折的，只要两点间存在区域没有被圆所覆盖，路径便可以经过。&lt;/p>
&lt;p>此时我首先想从数学上找出一些限制条件，或者使得两点间可达的充分必要条件，考虑将整个矩形划分为网格，一个点所能达到的地方便是其四周八个点。但是在考虑的过程中，我发现无论怎样划分网格，下一个节点的可达性总是不一定影响再下一个节点的可达性。&lt;/p>
&lt;p>此时选择从第二个方向思考，即考虑在怎样的情况下，所有可达的路径被圆覆盖。&lt;/p>
&lt;p>由于最终所求的路径是从左下角到右上角，可以发现，只要从左边界或者上边界有一个连续的区域直达下边界或者右边界即可以确定不存在路径从左下角到右上角。如下图：&lt;/p>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/image-1.png" alt="alt text">&lt;/p>
&lt;p>即只需确定一系列连续的圆从左边界或者上边界出发，可以从圆占据的区域内经过到达下边界或者右边界。这里考虑从左上边界出发（无论从哪边出发不影响结论）。而圆与圆间是否连续，可以通过两圆是否相交或者相切来判断。&lt;/p>
&lt;p>此外，在编写代码之前，我们可以有以下条件：&lt;/p>
&lt;ul>
&lt;li>任意一个圆，如果它与矩形区域没有任何重叠的地方，那么它不影响结论，可以去除&lt;/li>
&lt;li>如果左上边界（或者右下边界）没有任何一个圆穿过它与矩形内部相交，那么一定存在紧贴与这个边界的路径连接矩形的两个角落。&lt;/li>
&lt;li>如果两个圆虽然相交，但是相交的区域与矩形区域没有任何重叠，那么这种相交不能作为矩形内部圆连通的标志。&lt;/li>
&lt;/ul>
&lt;p>根据上述讨论，可以根据有效圆的相交相切关系，建立一棵表示连通关系的森林，森林中每一个节点即表示一个有效圆，每一条边表示一个有效连接关系。森林中每一棵树的根结点即为与左上边界相交或者相切的圆。&lt;strong>注意：任何一个圆不可以既作为根结点又作为与根结点具有连通关系的子节点&lt;/strong>&lt;/p>
&lt;p>之后根据广度搜索即可以探索出是否所有的路径都被阻塞。判断为被阻塞的终止条件是有节点与右下边界相交或者相切。&lt;/p>
&lt;h2 id="c代码实现">C++代码实现&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> canReachCorner(&lt;span style="color:#66d9ef">int&lt;/span> xCorner, &lt;span style="color:#66d9ef">int&lt;/span> yCorner, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;amp;&lt;/span> circles) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> path;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">auto&lt;/span> it&lt;span style="color:#f92672">=&lt;/span>circles.begin();it&lt;span style="color:#f92672">!=&lt;/span>circles.end();it&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> xCorner &lt;span style="color:#f92672">||&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> yCorner)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> circles.erase(it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> x1 &lt;span style="color:#f92672">=&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">0&lt;/span>), y1 &lt;span style="color:#f92672">=&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">1&lt;/span>), r1 &lt;span style="color:#f92672">=&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((pow(x1, &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> pow(y1, &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> pow(r1, &lt;span style="color:#ae81ff">2&lt;/span>)) &lt;span style="color:#f92672">||&lt;/span> (pow(x1, &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> pow(y1 &lt;span style="color:#f92672">-&lt;/span> yCorner, &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> pow(r1, &lt;span style="color:#ae81ff">2&lt;/span>)) &lt;span style="color:#f92672">||&lt;/span> (abs(x1) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> r1 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> y1 &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> y1 &lt;span style="color:#f92672">&amp;lt;=&lt;/span> yCorner) &lt;span style="color:#f92672">||&lt;/span> (abs(y1 &lt;span style="color:#f92672">-&lt;/span> yCorner) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> r1 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> x1 &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> x1 &lt;span style="color:#f92672">&amp;lt;=&lt;/span> xCorner) &lt;span style="color:#f92672">||&lt;/span> ((x1 &lt;span style="color:#f92672">-&lt;/span> xCorner)&lt;span style="color:#f92672">*&lt;/span>(x1 &lt;span style="color:#f92672">-&lt;/span> xCorner) &lt;span style="color:#f92672">+&lt;/span> (y1 &lt;span style="color:#f92672">-&lt;/span> yCorner)&lt;span style="color:#f92672">*&lt;/span>(y1 &lt;span style="color:#f92672">-&lt;/span> yCorner) &lt;span style="color:#f92672">-&lt;/span> r1&lt;span style="color:#f92672">*&lt;/span>r1 &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.push_back(&lt;span style="color:#f92672">*&lt;/span>it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> circles.erase(it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>circles.size() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>path.size())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (path.size())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> circle &lt;span style="color:#f92672">=&lt;/span> path.front();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.erase(path.begin());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> x2 &lt;span style="color:#f92672">=&lt;/span> circle[&lt;span style="color:#ae81ff">0&lt;/span>], y2 &lt;span style="color:#f92672">=&lt;/span> circle[&lt;span style="color:#ae81ff">1&lt;/span>], r2 &lt;span style="color:#f92672">=&lt;/span> circle[&lt;span style="color:#ae81ff">2&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>((x2&lt;span style="color:#f92672">*&lt;/span>x2 &lt;span style="color:#f92672">+&lt;/span> y2&lt;span style="color:#f92672">*&lt;/span>y2 &lt;span style="color:#f92672">&amp;lt;=&lt;/span> r2&lt;span style="color:#f92672">*&lt;/span>r2) &lt;span style="color:#f92672">||&lt;/span> ((x2 &lt;span style="color:#f92672">-&lt;/span> xCorner)&lt;span style="color:#f92672">*&lt;/span>(x2 &lt;span style="color:#f92672">-&lt;/span> xCorner) &lt;span style="color:#f92672">+&lt;/span> y2&lt;span style="color:#f92672">*&lt;/span>y2 &lt;span style="color:#f92672">&amp;lt;=&lt;/span> r2&lt;span style="color:#f92672">*&lt;/span>r2) &lt;span style="color:#f92672">||&lt;/span> ((x2 &lt;span style="color:#f92672">-&lt;/span> xCorner)&lt;span style="color:#f92672">*&lt;/span>(x2 &lt;span style="color:#f92672">-&lt;/span> xCorner) &lt;span style="color:#f92672">+&lt;/span> (y2 &lt;span style="color:#f92672">-&lt;/span> yCorner)&lt;span style="color:#f92672">*&lt;/span>(y2 &lt;span style="color:#f92672">-&lt;/span> yCorner) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> r2&lt;span style="color:#f92672">*&lt;/span>r2) &lt;span style="color:#f92672">||&lt;/span> (abs(x2 &lt;span style="color:#f92672">-&lt;/span> xCorner) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> r2 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> y2 &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> y2 &lt;span style="color:#f92672">&amp;lt;=&lt;/span> yCorner) &lt;span style="color:#f92672">||&lt;/span> (abs(y2) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> r2 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> x2 &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> x2 &lt;span style="color:#f92672">&amp;lt;=&lt;/span> xCorner))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> it&lt;span style="color:#f92672">=&lt;/span>circles.begin();it&lt;span style="color:#f92672">!=&lt;/span>circles.end();it&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x1 &lt;span style="color:#f92672">=&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">0&lt;/span>), y1 &lt;span style="color:#f92672">=&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">1&lt;/span>), r1 &lt;span style="color:#f92672">=&lt;/span> it&lt;span style="color:#f92672">-&amp;gt;&lt;/span>at(&lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> R &lt;span style="color:#f92672">=&lt;/span> sqrt((x1 &lt;span style="color:#f92672">-&lt;/span> x2)&lt;span style="color:#f92672">*&lt;/span>(x1 &lt;span style="color:#f92672">-&lt;/span> x2) &lt;span style="color:#f92672">+&lt;/span> (y1 &lt;span style="color:#f92672">-&lt;/span> y2)&lt;span style="color:#f92672">*&lt;/span>(y1 &lt;span style="color:#f92672">-&lt;/span> y2));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> R_2 &lt;span style="color:#f92672">=&lt;/span> (x1 &lt;span style="color:#f92672">-&lt;/span> x2)&lt;span style="color:#f92672">*&lt;/span>(x1 &lt;span style="color:#f92672">-&lt;/span> x2) &lt;span style="color:#f92672">+&lt;/span> (y1 &lt;span style="color:#f92672">-&lt;/span> y2)&lt;span style="color:#f92672">*&lt;/span>(y1 &lt;span style="color:#f92672">-&lt;/span> y2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(R_2 &lt;span style="color:#f92672">&amp;lt;=&lt;/span> (r1 &lt;span style="color:#f92672">+&lt;/span> r2)&lt;span style="color:#f92672">*&lt;/span>(r1 &lt;span style="color:#f92672">+&lt;/span> r2))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> r1_2 &lt;span style="color:#f92672">=&lt;/span> pow(r1, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> r2_2 &lt;span style="color:#f92672">=&lt;/span> pow(r2, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> temp1 &lt;span style="color:#f92672">=&lt;/span> (r1_2 &lt;span style="color:#f92672">-&lt;/span> r2_2) &lt;span style="color:#f92672">/&lt;/span> (&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>R_2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> temp2 &lt;span style="color:#f92672">=&lt;/span> (sqrt(&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>(r1_2 &lt;span style="color:#f92672">+&lt;/span> r2_2) &lt;span style="color:#f92672">/&lt;/span> R_2 &lt;span style="color:#f92672">-&lt;/span> pow(r1_2 &lt;span style="color:#f92672">-&lt;/span>r2_2, &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> pow(R_2, &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> a1 &lt;span style="color:#f92672">=&lt;/span> (x1 &lt;span style="color:#f92672">+&lt;/span> x2)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> temp1 &lt;span style="color:#f92672">*&lt;/span> (x2 &lt;span style="color:#f92672">-&lt;/span> x1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> a2 &lt;span style="color:#f92672">=&lt;/span> (y2 &lt;span style="color:#f92672">-&lt;/span> y1) &lt;span style="color:#f92672">*&lt;/span> temp2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> b1 &lt;span style="color:#f92672">=&lt;/span> (y1 &lt;span style="color:#f92672">+&lt;/span> y2)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> temp1 &lt;span style="color:#f92672">*&lt;/span> (y2 &lt;span style="color:#f92672">-&lt;/span> y1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> b2 &lt;span style="color:#f92672">=&lt;/span> (x1 &lt;span style="color:#f92672">-&lt;/span> x2) &lt;span style="color:#f92672">*&lt;/span> temp2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((a1 &lt;span style="color:#f92672">+&lt;/span> a2 &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> b1 &lt;span style="color:#f92672">+&lt;/span> b2 &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> a1 &lt;span style="color:#f92672">-&lt;/span> a2 &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> b1 &lt;span style="color:#f92672">-&lt;/span> b2 &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> (a1 &lt;span style="color:#f92672">+&lt;/span> a2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> xCorner &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> b1 &lt;span style="color:#f92672">+&lt;/span> b2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> yCorner &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> a1 &lt;span style="color:#f92672">-&lt;/span> a2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> xCorner &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> b1 &lt;span style="color:#f92672">-&lt;/span> b2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> yCorner))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.push_back(&lt;span style="color:#f92672">*&lt;/span>it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> circles.erase(it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>操作系统实验三--动态模块与设备驱动</title><link>https://xiongyuaay.github.io/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89--%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97%E4%B8%8E%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</link><pubDate>Tue, 12 Nov 2024 17:46:10 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89--%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97%E4%B8%8E%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</guid><description>&lt;p>在进行实验之前，查阅相关Makefile编写教程，链接如下：
&lt;a href="https://zhuanlan.zhihu.com/p/47390641">Makefile由浅入深&amp;ndash;教程、干货&lt;/a>&lt;/p>
&lt;p>部分常用的预定义变量记录如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>$* 不包含扩展名的目标文件名称 
$+ 所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件
$&amp;lt; 第一个依赖文件的名称 
$? 所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚
$@ 目标的完整名称 ****
$^ 所有的依赖文件，以空格分开，不包含重复的依赖文件
$% 如果目标是归档成员，则该变量表示目标的归档成员名称
&lt;/code>&lt;/pre>&lt;p>&lt;strong>注意：目标文件，表示最终生成的可执行文件；依赖文件是目标文件生成所需的文件。它们是目标文件的输入，通常是源代码、配置文件或脚本等。&lt;/strong>&lt;/p>
&lt;p>如以下例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">target&lt;/span>&lt;span style="color:#f92672">:&lt;/span> dep1.o dep2.o
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $@
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $^
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $&amp;lt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $?
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行 make 时：&lt;/p>
&lt;pre tabindex="0">&lt;code>$@ → target $^ → dep1.o dep2.o （去重）
$+ → dep1.o dep2.o （可以重复） $&amp;lt; → dep1.o （第一个依赖文件）
$? → 如果 dep1.o 和 dep2.o 中有更新的，列出更新的依赖文件。
&lt;/code>&lt;/pre>&lt;h1 id="v26动态模块示例加载">V2.6动态模块示例加载&lt;/h1>
&lt;p>考虑到在阅读课件ppt以及实验指导书后，对动态模块仍有很多疑惑，如：&lt;/p>
&lt;ul>
&lt;li>动态模块源代码存放位置是否有要求？
&lt;ul>
&lt;li>没有要求。动态模块源代码应与Makefile文件在同一个文件夹下&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如何开始动态模块源代码的编写？
&lt;ul>
&lt;li>在任意位置编写动态模块源代码及Makefile文件&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如何编译动态模块？
&lt;ul>
&lt;li>编写Makefile文件编译&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如何查看当前主机linux可用动态模块编译版本？
&lt;ul>
&lt;li>使用uname -r查看当前版本&lt;/li>
&lt;li>且当前版本的动态模块机制与 2.6 及其后的版本保持一致。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>使用chatgpt询问后，部分疑惑解答如上，详细问答可查看以下链接：
&lt;a href="https://chatgpt.com/share/673870fb-f134-8005-aa82-354020349f3f">chatgpt询问动态模块疑惑&lt;/a>&lt;/p></description></item><item><title>操作系统实验二--进程通信与内存管理</title><link>https://xiongyuaay.github.io/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Tue, 12 Nov 2024 17:46:10 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C--%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>&lt;h1 id="进程的软中断通信">进程的软中断通信&lt;/h1>
&lt;h2 id="查看帮助手册">查看帮助手册&lt;/h2>
&lt;h3 id="fork系统调用">fork系统调用&lt;/h3>
&lt;p>使用man命令查看fork系统调用结果如下图：&lt;/p>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/377594525772505.png" alt="1">&lt;/p>
&lt;p>可见结果显示没有相应的条目，猜测可能没有安装man帮助手册，通过以下资料查阅安装man手册。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/weixin_61939442/article/details/142136016#:~:text=Man%20%E6%89%8B%E5%86%8C%E5%AE%89%E8%A3%851.%E9%85%8D%E7%BD%AEman%20%5Broot%40myEuler%20~%5D%23%20dnf%20-y%20install%20man,https%3A%2F%2Fmirrors.edge.kernel.org%2Fpub%2Flinux%2Fdocs%2Fman-pages%2Fman-pages-6.03.tar.gz%20%5Broot%40myEuler%20~%5D%23%20tar%20-xzvf%20man-pages-6.03.tar.gz4.%E5%AE%89%E8%A3%85man%E6%89%8B%E5%86%8C%23%E8%BF%9B%E5%85%A5%E7%9B%AE%E6%A0%87%E7%9B%AE%E5%BD%95%20%5Br_openeuler%20man%E6%89%8B%E5%86%8C%E5%AE%89%E8%A3%85">man手册安装&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>使用的安装命令及结果如下图：&lt;br>
&lt;img src="https://xiongyuaay.github.io/images/443453311011602.png" alt="2">&lt;/p>
&lt;p>可见在安装好man手册，成功使用man fork命令，如下图：
&lt;img src="https://xiongyuaay.github.io/images/167935907718258.png" alt="">&lt;/p>
&lt;h3 id="kill系统调用">kill系统调用&lt;/h3>
&lt;p>结果如下图：&lt;br>
&lt;img src="https://xiongyuaay.github.io/images/344455056047998.png" alt="">&lt;/p>
&lt;h3 id="signal系统调用">signal系统调用&lt;/h3>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/116624541508.png" alt="">&lt;/p>
&lt;h3 id="sleep系统调用">sleep系统调用&lt;/h3>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/427004511623406.png" alt="">&lt;/p>
&lt;h3 id="exit系统调用">exit系统调用&lt;/h3>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/62306574070474.png" alt="">&lt;/p>
&lt;h2 id="软中断程序">软中断程序&lt;/h2>
&lt;p>openEuler系统下，使用命令kill -l查看所有信号及其编号的结果如下：
&lt;img src="https://xiongyuaay.github.io/images/24568132916712.png" alt="">&lt;/p>
&lt;p>补充完成进程软中断的程序代码如下，其中对于等待时间的要求，考虑到sleep过程可以被信号打断，选择通过sleep函数实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/wait.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;signal.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pid_t&lt;/span> pid1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, pid2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">inter_handler&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> signum) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用 kill() 发送整数值为 16 和 17 的信号
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (pid1 &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#a6e22e">kill&lt;/span>(pid1, &lt;span style="color:#ae81ff">16&lt;/span>); &lt;span style="color:#75715e">// 发送信号 16 给子进程1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (pid2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#a6e22e">kill&lt;/span>(pid2, &lt;span style="color:#ae81ff">17&lt;/span>); &lt;span style="color:#75715e">// 发送信号 17 给子进程2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Parent received signal %d, sending signals 16 and 17 to child processes&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, signum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">waiting&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> signum) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Child process received signal %d, exiting...&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, signum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">exit&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建子进程1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> (pid1 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) pid1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fork&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pid1 &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建子进程2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> (pid2 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) pid2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fork&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pid2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 父进程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signal&lt;/span>(SIGINT, inter_handler); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">signal&lt;/span>(SIGQUIT, inter_handler); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wait&lt;/span>(NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">wait&lt;/span>(NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">Parent process is killed!!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 子进程2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signal&lt;/span>(&lt;span style="color:#ae81ff">17&lt;/span>, waiting); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sleep&lt;/span>(&lt;span style="color:#ae81ff">5&lt;/span>); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">Child process 2 is waiting for signal 17...&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 子进程1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">signal&lt;/span>(&lt;span style="color:#ae81ff">16&lt;/span>, waiting); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sleep&lt;/span>(&lt;span style="color:#ae81ff">5&lt;/span>); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">Child process 1 is waiting for signal 16...&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>分别在5s内进行操作和不进行操作，编译运行结果如下：&lt;/p></description></item><item><title>数学建模 灰色关联分析（一点感悟）</title><link>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</link><pubDate>Sat, 09 Nov 2024 19:08:32 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</guid><description>&lt;h1 id="灰色关联分析">灰色关联分析&lt;/h1>
&lt;p>灰色关联分析用以分析影响目标的主要因素&lt;/p>
&lt;p>其中，用以分析的数据类型为序列形式，
需要确定原因的序列为母序列
需要衡量影响程度的为子序列
使用步骤：&lt;/p>
&lt;ul>
&lt;li>将所有序列全部标准化&lt;/li>
&lt;li>将母序列与子序列两两相减，计算两极最大差和两级最小差&lt;/li>
&lt;li>对每个元素计算灰色关联系数&lt;/li>
&lt;li>将灰色关联系数求平均值得到灰色关联度&lt;/li>
&lt;li>根据灰色关联度的大小下结论&lt;/li>
&lt;/ul>
&lt;p>部分使用到的公式如下：&lt;br>
&lt;img src="https://xiongyuaay.github.io/images/443974856105592.png" alt="1">
&lt;img src="https://xiongyuaay.github.io/images/544484652480945.png" alt="2">
&lt;img src="https://xiongyuaay.github.io/images/53064102515680.png" alt="3">&lt;/p></description></item><item><title>数学建模 Topsis（一点感悟）</title><link>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--topsis%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</link><pubDate>Sat, 09 Nov 2024 19:08:21 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--topsis%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</guid><description>&lt;h1 id="topsis">Topsis&lt;/h1>
&lt;p>本质上是针对多个指标，通过与最优解与最劣解间的距离来得到某个方案的评分&lt;/p>
&lt;p>可以很好的得到每个方案间的差距&lt;/p>
&lt;p>使用步骤：&lt;/p>
&lt;ul>
&lt;li>得到不同方案在不同指标的数据&lt;/li>
&lt;li>将同一指标不同方案的值正向化&lt;/li>
&lt;li>对得到的数据标准化，消除量纲的影响&lt;/li>
&lt;li>得到针对于这些指标的最优解与最劣解&lt;/li>
&lt;li>根据最优解与最劣解得到每个方案的评分
&lt;ul>
&lt;li>&lt;strong>注意，如果每个指标的重要程度不一样，可以先通过其他赋予权值方法得到权重，将权重与距离求解结合，得到评分&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>计算最优解、最劣解的公式：
&lt;img src="https://xiongyuaay.github.io/images/337922171116636.png" alt="1">
带权重的计算公式：
&lt;img src="https://xiongyuaay.github.io/images/533552640375792.png" alt="2">&lt;/p></description></item><item><title>数学建模 熵权法（一点感悟）</title><link>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E7%86%B5%E6%9D%83%E6%B3%95%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</link><pubDate>Sat, 09 Nov 2024 19:08:10 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E7%86%B5%E6%9D%83%E6%B3%95%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</guid><description>&lt;h1 id="熵权法">熵权法&lt;/h1>
&lt;p>一种基于数据本身的客观的赋予权重的方法
利用信息熵，衡量了掌握信息的确切程度
&lt;strong>值得注意的是，这种信息熵是基于方案的而不是基于指标。衡量了所有方案在这个指标的信息掌握程度。&lt;/strong>&lt;/p>
&lt;p>最终的权重衡量这个指标距离理想情况的重要程度，
我认为，最好在所有指标都很重要、且每种指标重要程度差不多的情况下使用&lt;/p>
&lt;p>使用步骤&lt;/p>
&lt;ul>
&lt;li>得到影响最终决策的因素（指标）&lt;/li>
&lt;li>得到不同方案在这些因素的值&lt;/li>
&lt;li>将这些值按指标正向化
&lt;ul>
&lt;li>极大型指标&lt;/li>
&lt;li>中间型指标&lt;/li>
&lt;li>极小型指标&lt;/li>
&lt;li>区间型指标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将这些指标按列标准化&lt;/li>
&lt;li>对每一个指标计算信息熵
&lt;ul>
&lt;li>&lt;strong>注意，这里使用的是改进了的公式，方便之后计算权重&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>根据信息熵得到权重&lt;/li>
&lt;/ul>
&lt;p>计算信息熵时所用公式：&lt;br>
&lt;img src="https://xiongyuaay.github.io/images/222104284080536.png" alt="1">&lt;/p>
&lt;p>标准化时可以用到的一些示例方法：&lt;br>
&lt;img src="https://xiongyuaay.github.io/images/587765196388639.png" alt="2">&lt;/p></description></item><item><title>数学建模 网络最大流</title><link>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/</link><pubDate>Sat, 09 Nov 2024 19:08:10 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/</guid><description>&lt;p>网络最大流都是建立在流网络上的，流网络可以被表示为一个有向图&lt;/p>
&lt;p>并且在这个有向图中，每条边同时有两个属性：&lt;/p>
&lt;ul>
&lt;li>当前边的最大容量&lt;/li>
&lt;li>当前边的已使用容量&lt;/li>
&lt;/ul>
&lt;p>同时对于图中的每一个节点，所有流入当前节点的容量等于所有流出该节点的容量&lt;/p>
&lt;p>下边是一个流网络的示例：&lt;/p>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/320496241621225.png" alt="">&lt;/p>
&lt;p>求解网络最大流问题就是求解网络的一种状态，使得源节点到目标节点的流量最大。&lt;/p>
&lt;h2 id="求解方法">求解方法&lt;/h2>
&lt;p>要求解这个问题只须依次找到该网络的所有增广路，并通过合适的方式消除增广路即可。
增广路指的是网络中一条从源节点到目标节点的路径，在该路径上增加流量而不会使得某一条边的负载超出其最大负载。&lt;/p>
&lt;p>在Ford Fulkerson求解算法中
对于除源节点以外的任意一个节点$V_j$用标号$(+V_{i}, /Delta_{j})$，其中用‘+’表示前向弧，‘-’表示反向弧，$/Delta_{j}$表示改变量。其中，源节点用$(0, 正无穷大)$，即假定从源节点有源源不断的输入。&lt;/p>
&lt;ul>
&lt;li>从源节点出发，依次寻找源节点可以抵达的下一个节点，如果存在可用的容量，延伸到下一个节点，其中$/Delta_{j}$使用上一个节点与延伸节点中较小的值&lt;/li>
&lt;li>重复进行直到延伸到目标节点，其中，在下方的例子中，通过该增广链可增加的量为$min(正无穷, 1, 1, 1) = 1$。最终使得该增广链上的每一条弧都+1。&lt;/li>
&lt;li>重复进行直到网络中没有增广路，即为最终的最大流。
&lt;img src="https://xiongyuaay.github.io/images/347707393535425.png" alt="">&lt;/li>
&lt;/ul></description></item><item><title>数学建模 模糊评价（一点感悟）</title><link>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E6%A8%A1%E7%B3%8A%E8%AF%84%E4%BB%B7%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</link><pubDate>Sat, 09 Nov 2024 19:08:01 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E6%A8%A1%E7%B3%8A%E8%AF%84%E4%BB%B7%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</guid><description>&lt;h1 id="模糊评价">模糊评价&lt;/h1>
&lt;p>对某一个对象，有一个总的评判结果，
可以将这个评判结果作为一个集合
如{优， 良， 差}等&lt;/p>
&lt;p>目前已知影响这个对象的一些因素的实际值
&lt;strong>注意：这些实际值都只是单个值&lt;/strong>&lt;/p>
&lt;p>根据这些因素的实际意义，给出这些因素相对于不同评语的隶属函数
&lt;strong>由F分布得到隶属函数&lt;/strong>
&lt;img src="https://xiongyuaay.github.io/images/146262814940887.png" alt="隶属函数">
从而可以得到这些因素对不同评语的隶属度&lt;/p>
&lt;p>对这些因素之间，可以通过其他方法，&lt;strong>如：层次分析法、熵权法等&lt;/strong>，确定对总体研究对象的权重，
借由这些权重，可以得到该总体对象在这个评语集的隶属度，
最后，根据隶属度，选择最高的可以判断该对象属于哪一个层次。&lt;/p>
&lt;p>可以用以离散化的评价，结果为评语集的不同隶属度。&lt;/p></description></item><item><title>数学建模 层次分析法（一点感悟）</title><link>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</link><pubDate>Sat, 09 Nov 2024 18:47:27 +0800</pubDate><guid>https://xiongyuaay.github.io/posts/math/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1--%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</guid><description>&lt;h1 id="ahp">AHP&lt;/h1>
&lt;p>主观赋值评价方法，多指标&lt;/p>
&lt;ul>
&lt;li>构造判断矩阵&lt;/li>
&lt;li>利用判断矩阵计算权重&lt;/li>
&lt;li>判断一致性是否通过&lt;/li>
&lt;li>得到该层相对于上一层的权重&lt;/li>
&lt;li>最底层可直接将该层权重作为其相对与上一层指标的得分&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>具体计算权重与一致性公式使用时查阅&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/111586079287530.png" alt="santy赋值">&lt;/p>
&lt;h2 id="流程">流程&lt;/h2>
&lt;p>&lt;img src="https://xiongyuaay.github.io/images/568745427628904.png" alt="流程图">&lt;/p></description></item></channel></rss>