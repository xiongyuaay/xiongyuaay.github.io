<!doctype html><html lang=en><head><title>LeetCode--判断矩形的两个角落是否可达 // yuaay</title>
<link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.138.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="yuaay"><meta name=description content><link rel=stylesheet href=/css/main.min.6ebe00cfa7759a5c422430d5c2a659c696627ccf19379685a28a3aec1859af90.css><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode--判断矩形的两个角落是否可达"><meta name=twitter:description content="来记录一下最近写的LeetCode算法题，以免以后遗忘。“判断矩形的两个角落是否可达”是LeetCode上序号为3235的一道困难题，实现起来颇为复杂，现将整个思考解答过程记录如下：
题目 给你两个正整数 xCorner 和 yCorner 和一个二维整数数组 circles ，其中 circles[i] = [xi, yi, ri] 表示一个圆心在 (xi, yi) 半径为 ri 的圆。
坐标平面内有一个左下角在原点，右上角在 (xCorner, yCorner) 的矩形。你需要判断是否存在一条从左下角到右上角的路径满足：路径 完全 在矩形内部，不会 触碰或者经过 任何 圆的内部和边界，同时 只 在起点和终点接触到矩形。
如果存在这样的路径，请你返回 true ，否则返回 false 。
以下是官网给的示例，便于理解题目意思：
解题思路 分析题目，我认为可以从两个方面去考虑：
找到可以连接矩形两个角落的路径 证明所有的圆覆盖的区域完全阻塞了可能的路径 首先从第一个方向思考，要找到可以连接矩形两个角落的路径，可以从起点出发，不断探索可以延申的方向，通过深度搜索或者广度搜索，如果可以探索到一条到达右上角（目的角落）的路径，即说明存在这样的路径，如果遍历完全后，仍然没有可行解，则说明起点与终点之间被完全阻塞了。
考虑到在进行深度搜索或者广度搜索时，从一个节点出发的下一个节点的可能性是有限的，并且总的节点数目也应该是有限的，这样才能确保搜索到所有可能的路径。
但是题目中，并没有限制路径的经过节点，这条可能的路径将是可以任意曲折的，只要两点间存在区域没有被圆所覆盖，路径便可以经过。
此时我首先想从数学上找出一些限制条件，或者使得两点间可达的充分必要条件，考虑将整个矩形划分为网格，一个点所能达到的地方便是其四周八个点。但是在考虑的过程中，我发现无论怎样划分网格，下一个节点的可达性总是不一定影响再下一个节点的可达性。
此时选择从第二个方向思考，即考虑在怎样的情况下，所有可达的路径被圆覆盖。
由于最终所求的路径是从左下角到右上角，可以发现，只要从左边界或者上边界有一个连续的区域直达下边界或者右边界即可以确定不存在路径从左下角到右上角。如下图：
即只需确定一系列连续的圆从左边界或者上边界出发，可以从圆占据的区域内经过到达下边界或者右边界。这里考虑从左上边界出发（无论从哪边出发不影响结论）。而圆与圆间是否连续，可以通过两圆是否相交或者相切来判断。
此外，在编写代码之前，我们可以有以下条件：
任意一个圆，如果它与矩形区域没有任何重叠的地方，那么它不影响结论，可以去除 如果左上边界（或者右下边界）没有任何一个圆穿过它与矩形内部相交，那么一定存在紧贴与这个边界的路径连接矩形的两个角落。 如果两个圆虽然相交，但是相交的区域与矩形区域没有任何重叠，那么这种相交不能作为矩形内部圆连通的标志。 根据上述讨论，可以根据有效圆的相交相切关系，建立一棵表示连通关系的森林，森林中每一个节点即表示一个有效圆，每一条边表示一个有效连接关系。森林中每一棵树的根结点即为与左上边界相交或者相切的圆。注意：任何一个圆不可以既作为根结点又作为与根结点具有连通关系的子节点
之后根据广度搜索即可以探索出是否所有的路径都被阻塞。判断为被阻塞的终止条件是有节点与右下边界相交或者相切。
C++代码实现 class Solution { public: bool canReachCorner(int xCorner, int yCorner, vector<vector<int>>& circles) { vector<vector<int>> path; for(auto it=circles.begin();it!=circles.end();it++) { if (it->at(0) + it->at(2) <= 0 || it->at(0) - it->at(2) >= xCorner || it->at(1) + it->at(2) <= 0 || it->at(1) - it->at(2) >= yCorner) { circles.erase(it); it--; continue; } long long x1 = it->at(0), y1 = it->at(1), r1 = it->at(2); if ((pow(x1, 2) + pow(y1, 2) <= pow(r1, 2)) || (pow(x1, 2) + pow(y1 - yCorner, 2) <= pow(r1, 2)) || (abs(x1) <= r1 && y1 >= 0 && y1 <= yCorner) || (abs(y1 - yCorner) <= r1 && x1 >= 0 && x1 <= xCorner) || ((x1 - xCorner)*(x1 - xCorner) + (y1 - yCorner)*(y1 - yCorner) - r1*r1 <= 0)) { path.push_back(*it); circles.erase(it); it--; } } if(!circles.size() && !path.size()) { return true; } while (path.size()) { vector<int> circle = path.front(); path.erase(path.begin()); long long x2 = circle[0], y2 = circle[1], r2 = circle[2]; if((x2*x2 + y2*y2 <= r2*r2) || ((x2 - xCorner)*(x2 - xCorner) + y2*y2 <= r2*r2) || ((x2 - xCorner)*(x2 - xCorner) + (y2 - yCorner)*(y2 - yCorner) <= r2*r2) || (abs(x2 - xCorner) <= r2 && y2 >= 0 && y2 <= yCorner) || (abs(y2) <= r2 && x2 >= 0 && x2 <= xCorner)) { return false; } for (auto it=circles.begin();it!=circles.end();it++) { int x1 = it->at(0), y1 = it->at(1), r1 = it->at(2); long long R = sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2)); long long R_2 = (x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2); if(R_2 <= (r1 + r2)*(r1 + r2)) { double r1_2 = pow(r1, 2); double r2_2 = pow(r2, 2); double temp1 = (r1_2 - r2_2) / (2*R_2); double temp2 = (sqrt(2*(r1_2 + r2_2) / R_2 - pow(r1_2 -r2_2, 2) / pow(R_2, 2) - 1)) / 2; double a1 = (x1 + x2)/2 + temp1 * (x2 - x1); double a2 = (y2 - y1) * temp2; double b1 = (y1 + y2)/2 + temp1 * (y2 - y1); double b2 = (x1 - x2) * temp2; if ((a1 + a2 < 0 && b1 + b2 < 0 && a1 - a2 < 0 && b1 - b2 < 0) || (a1 + a2 > xCorner && b1 + b2 > yCorner && a1 - a2 > xCorner && b1 - b2 > yCorner)) { continue; } path.push_back(*it); circles.erase(it); it--; } } } return true; } };"><meta property="og:url" content="https://xiongyuaay.github.io/posts/leetcode/leetcode--%E5%88%A4%E6%96%AD%E7%9F%A9%E5%BD%A2%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A7%92%E8%90%BD%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BE%BE/"><meta property="og:site_name" content="yuaay"><meta property="og:title" content="LeetCode--判断矩形的两个角落是否可达"><meta property="og:description" content="来记录一下最近写的LeetCode算法题，以免以后遗忘。“判断矩形的两个角落是否可达”是LeetCode上序号为3235的一道困难题，实现起来颇为复杂，现将整个思考解答过程记录如下：
题目 给你两个正整数 xCorner 和 yCorner 和一个二维整数数组 circles ，其中 circles[i] = [xi, yi, ri] 表示一个圆心在 (xi, yi) 半径为 ri 的圆。
坐标平面内有一个左下角在原点，右上角在 (xCorner, yCorner) 的矩形。你需要判断是否存在一条从左下角到右上角的路径满足：路径 完全 在矩形内部，不会 触碰或者经过 任何 圆的内部和边界，同时 只 在起点和终点接触到矩形。
如果存在这样的路径，请你返回 true ，否则返回 false 。
以下是官网给的示例，便于理解题目意思：
解题思路 分析题目，我认为可以从两个方面去考虑：
找到可以连接矩形两个角落的路径 证明所有的圆覆盖的区域完全阻塞了可能的路径 首先从第一个方向思考，要找到可以连接矩形两个角落的路径，可以从起点出发，不断探索可以延申的方向，通过深度搜索或者广度搜索，如果可以探索到一条到达右上角（目的角落）的路径，即说明存在这样的路径，如果遍历完全后，仍然没有可行解，则说明起点与终点之间被完全阻塞了。
考虑到在进行深度搜索或者广度搜索时，从一个节点出发的下一个节点的可能性是有限的，并且总的节点数目也应该是有限的，这样才能确保搜索到所有可能的路径。
但是题目中，并没有限制路径的经过节点，这条可能的路径将是可以任意曲折的，只要两点间存在区域没有被圆所覆盖，路径便可以经过。
此时我首先想从数学上找出一些限制条件，或者使得两点间可达的充分必要条件，考虑将整个矩形划分为网格，一个点所能达到的地方便是其四周八个点。但是在考虑的过程中，我发现无论怎样划分网格，下一个节点的可达性总是不一定影响再下一个节点的可达性。
此时选择从第二个方向思考，即考虑在怎样的情况下，所有可达的路径被圆覆盖。
由于最终所求的路径是从左下角到右上角，可以发现，只要从左边界或者上边界有一个连续的区域直达下边界或者右边界即可以确定不存在路径从左下角到右上角。如下图：
即只需确定一系列连续的圆从左边界或者上边界出发，可以从圆占据的区域内经过到达下边界或者右边界。这里考虑从左上边界出发（无论从哪边出发不影响结论）。而圆与圆间是否连续，可以通过两圆是否相交或者相切来判断。
此外，在编写代码之前，我们可以有以下条件：
任意一个圆，如果它与矩形区域没有任何重叠的地方，那么它不影响结论，可以去除 如果左上边界（或者右下边界）没有任何一个圆穿过它与矩形内部相交，那么一定存在紧贴与这个边界的路径连接矩形的两个角落。 如果两个圆虽然相交，但是相交的区域与矩形区域没有任何重叠，那么这种相交不能作为矩形内部圆连通的标志。 根据上述讨论，可以根据有效圆的相交相切关系，建立一棵表示连通关系的森林，森林中每一个节点即表示一个有效圆，每一条边表示一个有效连接关系。森林中每一棵树的根结点即为与左上边界相交或者相切的圆。注意：任何一个圆不可以既作为根结点又作为与根结点具有连通关系的子节点
之后根据广度搜索即可以探索出是否所有的路径都被阻塞。判断为被阻塞的终止条件是有节点与右下边界相交或者相切。
C++代码实现 class Solution { public: bool canReachCorner(int xCorner, int yCorner, vector<vector<int>>& circles) { vector<vector<int>> path; for(auto it=circles.begin();it!=circles.end();it++) { if (it->at(0) + it->at(2) <= 0 || it->at(0) - it->at(2) >= xCorner || it->at(1) + it->at(2) <= 0 || it->at(1) - it->at(2) >= yCorner) { circles.erase(it); it--; continue; } long long x1 = it->at(0), y1 = it->at(1), r1 = it->at(2); if ((pow(x1, 2) + pow(y1, 2) <= pow(r1, 2)) || (pow(x1, 2) + pow(y1 - yCorner, 2) <= pow(r1, 2)) || (abs(x1) <= r1 && y1 >= 0 && y1 <= yCorner) || (abs(y1 - yCorner) <= r1 && x1 >= 0 && x1 <= xCorner) || ((x1 - xCorner)*(x1 - xCorner) + (y1 - yCorner)*(y1 - yCorner) - r1*r1 <= 0)) { path.push_back(*it); circles.erase(it); it--; } } if(!circles.size() && !path.size()) { return true; } while (path.size()) { vector<int> circle = path.front(); path.erase(path.begin()); long long x2 = circle[0], y2 = circle[1], r2 = circle[2]; if((x2*x2 + y2*y2 <= r2*r2) || ((x2 - xCorner)*(x2 - xCorner) + y2*y2 <= r2*r2) || ((x2 - xCorner)*(x2 - xCorner) + (y2 - yCorner)*(y2 - yCorner) <= r2*r2) || (abs(x2 - xCorner) <= r2 && y2 >= 0 && y2 <= yCorner) || (abs(y2) <= r2 && x2 >= 0 && x2 <= xCorner)) { return false; } for (auto it=circles.begin();it!=circles.end();it++) { int x1 = it->at(0), y1 = it->at(1), r1 = it->at(2); long long R = sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2)); long long R_2 = (x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2); if(R_2 <= (r1 + r2)*(r1 + r2)) { double r1_2 = pow(r1, 2); double r2_2 = pow(r2, 2); double temp1 = (r1_2 - r2_2) / (2*R_2); double temp2 = (sqrt(2*(r1_2 + r2_2) / R_2 - pow(r1_2 -r2_2, 2) / pow(R_2, 2) - 1)) / 2; double a1 = (x1 + x2)/2 + temp1 * (x2 - x1); double a2 = (y2 - y1) * temp2; double b1 = (y1 + y2)/2 + temp1 * (y2 - y1); double b2 = (x1 - x2) * temp2; if ((a1 + a2 < 0 && b1 + b2 < 0 && a1 - a2 < 0 && b1 - b2 < 0) || (a1 + a2 > xCorner && b1 + b2 > yCorner && a1 - a2 > xCorner && b1 - b2 > yCorner)) { continue; } path.push_back(*it); circles.erase(it); it--; } } } return true; } };"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-12T17:46:10+08:00"><meta property="article:modified_time" content="2024-11-12T17:46:10+08:00"><meta property="article:tag" content="LeetCode"></head><body><header class=app-header><a href=https://xiongyuaay.github.io/><img class=app-header-avatar src=/avatar.jpg alt=yuaay></a>
<span class=app-header-title>yuaay</span><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a></nav><p>电子世界的幽灵</p><div class=app-header-social><a href=https://github.com/xiongyuaay target=_blank rel="noreferrer noopener me"><svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentcolor"><title>GitHub</title><path d="M12 .297c-6.63.0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.606-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
</a><a href=xiongyuaay@gmail.com target=_blank rel="noreferrer noopener me"><svg class="icon icon-mail" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>mail</title><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>LeetCode--判断矩形的两个角落是否可达</h1><div class=post-meta><div><svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
Nov 12, 2024</div><div><svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
3 min read</div><div><svg class="icon icon-tag" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
<a class=tag href=https://xiongyuaay.github.io/tags/leetcode/>LeetCode</a></div></div></header><div class=post-content><p>来记录一下最近写的LeetCode算法题，以免以后遗忘。“判断矩形的两个角落是否可达”是LeetCode上序号为3235的一道困难题，实现起来颇为复杂，现将整个思考解答过程记录如下：</p><h2 id=题目>题目</h2><p>给你两个正整数 xCorner 和 yCorner 和一个二维整数数组 circles ，其中 circles[i] = [xi, yi, ri] 表示一个圆心在 (xi, yi) 半径为 ri 的圆。</p><p>坐标平面内有一个左下角在原点，右上角在 (xCorner, yCorner) 的矩形。你需要判断是否存在一条从左下角到右上角的路径满足：路径 完全 在矩形内部，不会 触碰或者经过 任何 圆的内部和边界，同时 只 在起点和终点接触到矩形。</p><p>如果存在这样的路径，请你返回 true ，否则返回 false 。</p><p>以下是官网给的示例，便于理解题目意思：</p><p><img src=/images/image.png alt="alt text"></p><h2 id=解题思路>解题思路</h2><p>分析题目，我认为可以从两个方面去考虑：</p><ul><li>找到可以连接矩形两个角落的路径</li><li>证明所有的圆覆盖的区域完全阻塞了可能的路径</li></ul><p>首先从第一个方向思考，要找到可以连接矩形两个角落的路径，可以从起点出发，不断探索可以延申的方向，通过深度搜索或者广度搜索，如果可以探索到一条到达右上角（目的角落）的路径，即说明存在这样的路径，如果遍历完全后，仍然没有可行解，则说明起点与终点之间被完全阻塞了。</p><p>考虑到在进行深度搜索或者广度搜索时，从一个节点出发的下一个节点的可能性是有限的，并且总的节点数目也应该是有限的，这样才能确保搜索到所有可能的路径。</p><p>但是题目中，并没有限制路径的经过节点，这条可能的路径将是可以任意曲折的，只要两点间存在区域没有被圆所覆盖，路径便可以经过。</p><p>此时我首先想从数学上找出一些限制条件，或者使得两点间可达的充分必要条件，考虑将整个矩形划分为网格，一个点所能达到的地方便是其四周八个点。但是在考虑的过程中，我发现无论怎样划分网格，下一个节点的可达性总是不一定影响再下一个节点的可达性。</p><p>此时选择从第二个方向思考，即考虑在怎样的情况下，所有可达的路径被圆覆盖。</p><p>由于最终所求的路径是从左下角到右上角，可以发现，只要从左边界或者上边界有一个连续的区域直达下边界或者右边界即可以确定不存在路径从左下角到右上角。如下图：</p><p><img src=/images/image-1.png alt="alt text"></p><p>即只需确定一系列连续的圆从左边界或者上边界出发，可以从圆占据的区域内经过到达下边界或者右边界。这里考虑从左上边界出发（无论从哪边出发不影响结论）。而圆与圆间是否连续，可以通过两圆是否相交或者相切来判断。</p><p>此外，在编写代码之前，我们可以有以下条件：</p><ul><li>任意一个圆，如果它与矩形区域没有任何重叠的地方，那么它不影响结论，可以去除</li><li>如果左上边界（或者右下边界）没有任何一个圆穿过它与矩形内部相交，那么一定存在紧贴与这个边界的路径连接矩形的两个角落。</li><li>如果两个圆虽然相交，但是相交的区域与矩形区域没有任何重叠，那么这种相交不能作为矩形内部圆连通的标志。</li></ul><p>根据上述讨论，可以根据有效圆的相交相切关系，建立一棵表示连通关系的森林，森林中每一个节点即表示一个有效圆，每一条边表示一个有效连接关系。森林中每一棵树的根结点即为与左上边界相交或者相切的圆。<strong>注意：任何一个圆不可以既作为根结点又作为与根结点具有连通关系的子节点</strong></p><p>之后根据广度搜索即可以探索出是否所有的路径都被阻塞。判断为被阻塞的终止条件是有节点与右下边界相交或者相切。</p><h2 id=c代码实现>C++代码实现</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> canReachCorner(<span style=color:#66d9ef>int</span> xCorner, <span style=color:#66d9ef>int</span> yCorner, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> circles) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> path;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> it<span style=color:#f92672>=</span>circles.begin();it<span style=color:#f92672>!=</span>circles.end();it<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>0</span>) <span style=color:#f92672>+</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>0</span>) <span style=color:#f92672>-</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>&gt;=</span> xCorner <span style=color:#f92672>||</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>1</span>) <span style=color:#f92672>-</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>&gt;=</span> yCorner)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                circles.erase(it);
</span></span><span style=display:flex><span>                it<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> x1 <span style=color:#f92672>=</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>0</span>), y1 <span style=color:#f92672>=</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>1</span>), r1 <span style=color:#f92672>=</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ((pow(x1, <span style=color:#ae81ff>2</span>) <span style=color:#f92672>+</span> pow(y1, <span style=color:#ae81ff>2</span>) <span style=color:#f92672>&lt;=</span> pow(r1, <span style=color:#ae81ff>2</span>)) <span style=color:#f92672>||</span> (pow(x1, <span style=color:#ae81ff>2</span>) <span style=color:#f92672>+</span> pow(y1 <span style=color:#f92672>-</span> yCorner, <span style=color:#ae81ff>2</span>) <span style=color:#f92672>&lt;=</span> pow(r1, <span style=color:#ae81ff>2</span>)) <span style=color:#f92672>||</span> (abs(x1) <span style=color:#f92672>&lt;=</span> r1 <span style=color:#f92672>&amp;&amp;</span> y1 <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> y1 <span style=color:#f92672>&lt;=</span> yCorner) <span style=color:#f92672>||</span> (abs(y1 <span style=color:#f92672>-</span> yCorner) <span style=color:#f92672>&lt;=</span> r1 <span style=color:#f92672>&amp;&amp;</span> x1 <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> x1 <span style=color:#f92672>&lt;=</span> xCorner) <span style=color:#f92672>||</span> ((x1 <span style=color:#f92672>-</span> xCorner)<span style=color:#f92672>*</span>(x1 <span style=color:#f92672>-</span> xCorner) <span style=color:#f92672>+</span> (y1 <span style=color:#f92672>-</span> yCorner)<span style=color:#f92672>*</span>(y1 <span style=color:#f92672>-</span> yCorner) <span style=color:#f92672>-</span> r1<span style=color:#f92672>*</span>r1 <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                path.push_back(<span style=color:#f92672>*</span>it);
</span></span><span style=display:flex><span>                circles.erase(it);
</span></span><span style=display:flex><span>                it<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>circles.size() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>path.size())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (path.size())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> circle <span style=color:#f92672>=</span> path.front();
</span></span><span style=display:flex><span>            path.erase(path.begin());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> x2 <span style=color:#f92672>=</span> circle[<span style=color:#ae81ff>0</span>], y2 <span style=color:#f92672>=</span> circle[<span style=color:#ae81ff>1</span>], r2 <span style=color:#f92672>=</span> circle[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>((x2<span style=color:#f92672>*</span>x2 <span style=color:#f92672>+</span> y2<span style=color:#f92672>*</span>y2 <span style=color:#f92672>&lt;=</span> r2<span style=color:#f92672>*</span>r2) <span style=color:#f92672>||</span> ((x2 <span style=color:#f92672>-</span> xCorner)<span style=color:#f92672>*</span>(x2 <span style=color:#f92672>-</span> xCorner) <span style=color:#f92672>+</span> y2<span style=color:#f92672>*</span>y2 <span style=color:#f92672>&lt;=</span> r2<span style=color:#f92672>*</span>r2) <span style=color:#f92672>||</span> ((x2 <span style=color:#f92672>-</span> xCorner)<span style=color:#f92672>*</span>(x2 <span style=color:#f92672>-</span> xCorner) <span style=color:#f92672>+</span> (y2 <span style=color:#f92672>-</span> yCorner)<span style=color:#f92672>*</span>(y2 <span style=color:#f92672>-</span> yCorner) <span style=color:#f92672>&lt;=</span> r2<span style=color:#f92672>*</span>r2) <span style=color:#f92672>||</span> (abs(x2 <span style=color:#f92672>-</span> xCorner) <span style=color:#f92672>&lt;=</span> r2 <span style=color:#f92672>&amp;&amp;</span> y2 <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> y2 <span style=color:#f92672>&lt;=</span> yCorner) <span style=color:#f92672>||</span> (abs(y2) <span style=color:#f92672>&lt;=</span> r2 <span style=color:#f92672>&amp;&amp;</span> x2 <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> x2 <span style=color:#f92672>&lt;=</span> xCorner))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it<span style=color:#f92672>=</span>circles.begin();it<span style=color:#f92672>!=</span>circles.end();it<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> x1 <span style=color:#f92672>=</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>0</span>), y1 <span style=color:#f92672>=</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>1</span>), r1 <span style=color:#f92672>=</span> it<span style=color:#f92672>-&gt;</span>at(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> R <span style=color:#f92672>=</span> sqrt((x1 <span style=color:#f92672>-</span> x2)<span style=color:#f92672>*</span>(x1 <span style=color:#f92672>-</span> x2) <span style=color:#f92672>+</span> (y1 <span style=color:#f92672>-</span> y2)<span style=color:#f92672>*</span>(y1 <span style=color:#f92672>-</span> y2));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> R_2 <span style=color:#f92672>=</span> (x1 <span style=color:#f92672>-</span> x2)<span style=color:#f92672>*</span>(x1 <span style=color:#f92672>-</span> x2) <span style=color:#f92672>+</span> (y1 <span style=color:#f92672>-</span> y2)<span style=color:#f92672>*</span>(y1 <span style=color:#f92672>-</span> y2);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(R_2 <span style=color:#f92672>&lt;=</span> (r1 <span style=color:#f92672>+</span> r2)<span style=color:#f92672>*</span>(r1 <span style=color:#f92672>+</span> r2))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>double</span> r1_2 <span style=color:#f92672>=</span> pow(r1, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>double</span> r2_2 <span style=color:#f92672>=</span> pow(r2, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>double</span> temp1 <span style=color:#f92672>=</span> (r1_2 <span style=color:#f92672>-</span> r2_2) <span style=color:#f92672>/</span> (<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>R_2);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>double</span> temp2 <span style=color:#f92672>=</span> (sqrt(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>(r1_2 <span style=color:#f92672>+</span> r2_2) <span style=color:#f92672>/</span> R_2 <span style=color:#f92672>-</span> pow(r1_2 <span style=color:#f92672>-</span>r2_2, <span style=color:#ae81ff>2</span>) <span style=color:#f92672>/</span> pow(R_2, <span style=color:#ae81ff>2</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>double</span> a1 <span style=color:#f92672>=</span> (x1 <span style=color:#f92672>+</span> x2)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> temp1 <span style=color:#f92672>*</span> (x2 <span style=color:#f92672>-</span> x1);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>double</span> a2 <span style=color:#f92672>=</span> (y2 <span style=color:#f92672>-</span> y1) <span style=color:#f92672>*</span> temp2;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>double</span> b1 <span style=color:#f92672>=</span> (y1 <span style=color:#f92672>+</span> y2)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> temp1 <span style=color:#f92672>*</span> (y2 <span style=color:#f92672>-</span> y1);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>double</span> b2 <span style=color:#f92672>=</span> (x1 <span style=color:#f92672>-</span> x2) <span style=color:#f92672>*</span> temp2;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> ((a1 <span style=color:#f92672>+</span> a2 <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> b1 <span style=color:#f92672>+</span> b2 <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> a1 <span style=color:#f92672>-</span> a2 <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> b1 <span style=color:#f92672>-</span> b2 <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>||</span> (a1 <span style=color:#f92672>+</span> a2 <span style=color:#f92672>&gt;</span> xCorner <span style=color:#f92672>&amp;&amp;</span> b1 <span style=color:#f92672>+</span> b2 <span style=color:#f92672>&gt;</span> yCorner <span style=color:#f92672>&amp;&amp;</span> a1 <span style=color:#f92672>-</span> a2 <span style=color:#f92672>&gt;</span> xCorner <span style=color:#f92672>&amp;&amp;</span> b1 <span style=color:#f92672>-</span> b2 <span style=color:#f92672>&gt;</span> yCorner))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    path.push_back(<span style=color:#f92672>*</span>it);
</span></span><span style=display:flex><span>                    circles.erase(it);
</span></span><span style=display:flex><span>                    it<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div><div class=post-footer></div></article></main></body></html>